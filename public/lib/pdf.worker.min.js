/**
 * @licstart The following is the entire license notice for the
 * Javascript code in this page
 *
 * Copyright 2024 Mozilla Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS-IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * @licend The above is the entire license notice for the
 * Javascript code in this page
 */

/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
var __webpack_exports__ = {};

;// CONCATENATED MODULE: ./src/shared/util.js
const deprecated = (details, ...subst) => {
  console.warn(`[DEPRECATED] ${details}`, ...subst);
};
function getVerbosityLevel() {
  return 2;
}
function setVerbosityLevel(level) {
  if (typeof level !== "number" || !Number.isInteger(level) || level < 0 || level > 4) {
    throw new Error(`Invalid verbosity level: ${level}`);
  }
}
function getVerbosity() {
  return 2;
}
function setVerbosity(verbosity) {}
function shadow(obj, prop, value) {
  Object.defineProperty(obj, prop, {
    value,
    enumerable: true,
    configurable: true,
    writable: false
  });
  return value;
}
class BaseException extends Error {
  constructor(message) {
    super(message);
    this.name = this.constructor.name;
  }
}
class MissingPDFException extends BaseException {
  constructor(message) {
    super(message || "Missing PDF file.");
  }
}
class UnexpectedResponseException extends BaseException {
  constructor(message, status) {
    super(message);
    this.status = status;
  }
}
class NotImplementedException extends BaseException {
  constructor(message) {
    super(message || "Not implemented.");
  }
}
class PasswordException extends BaseException {
  constructor(message, code) {
    super(message);
    this.code = code;
  }
}
class UnknownErrorException extends BaseException {
  constructor(message, details) {
    super(message);
    this.details = details;
  }
}
class InvalidPDFException extends BaseException {
  constructor(message) {
    super(message || "Invalid PDF structure.");
  }
}
class FormatError extends BaseException {
  constructor(message, details) {
    super(message, details);
  }
}
class XRefEntryException extends BaseException {}
class XRefParseException extends BaseException {}
class StatTimer {
  #start = Object.create(null);
  #times = [];
  time(name) {
    if (this.#start[name]) {
      throw new Error("Timer is already running for " + name);
    }
    this.#start[name] = Date.now();
  }
  timeEnd(name) {
    if (!this.#start[name]) {
      throw new Error("Timer has not been started for " + name);
    }
    this.#times.push({
      name,
      start: this.#start[name],
      end: Date.now()
    });
    delete this.#start[name];
  }
  get times() {
    return this.#times;
  }
}
function bytesToString(bytes) {
  let str = "";
  for (let i = 0, ii = bytes.length; i < ii; i++) {
    str += String.fromCharCode(bytes[i]);
  }
  return str;
}
function stringToBytes(str) {
  if (typeof str !== "string") {
    throw new Error("Invalid argument for stringToBytes");
  }
  const length = str.length;
  const bytes = new Uint8Array(length);
  for (let i = 0; i < length; i++) {
    bytes[i] = str.charCodeAt(i) & 0xff;
  }
  return bytes;
}
function stringToUTF8String(str) {
  return decodeURIComponent(escape(str));
}
function utf8StringToString(str) {
  return unescape(encodeURIComponent(str));
}
function getLookupTableFactory(initializer) {
  let lookup;
  return function () {
    if (!lookup) {
      lookup = initializer();
    }
    return lookup;
  };
}
function arrayBuffersToBytes(buffers) {
  let totalLength = 0;
  for (const buffer of buffers) {
    totalLength += buffer.byteLength;
  }
  const bytes = new Uint8Array(totalLength);
  let offset = 0;
  for (const buffer of buffers) {
    bytes.set(new Uint8Array(buffer), offset);
    offset += buffer.byteLength;
  }
  return bytes;
}
function abort(why) {
  throw new Error(why);
}
function assert(cond, ...args) {
  if (cond) {
    return;
  }
  let message;
  if (typeof args[0] === "function") {
    message = args[0]();
  } else {
    message = args[0] || "assert";
  }
  throw new Error(`Assertion failed: ${message}`);
}
function createPromiseCapability() {
  const capability = {
    promise: null,
    resolve: null,
    reject: null
  };
  capability.promise = new Promise(function (resolve, reject) {
    capability.resolve = resolve;
    capability.reject = reject;
  });
  return capability;
}
function isNodeJS() {
  return typeof process?.versions?.node === "string";
}
function loadScript(src) {
  return new Promise(function (resolve, reject) {
    const script = document.createElement("script");
    script.src = src;
    script.onload = resolve;
    script.onerror = function () {
      reject(new Error(`Cannot load script at: ${script.src}`));
    };
    (document.head || document.documentElement).append(script);
  });
}
function getPackageVersion(name) {
  return "4.2.67";
}
function extractFilenameFromHeader(dispositionHeader) {
  const result = /filename\s*=\s*"([^"]+)"/i.exec(dispositionHeader) || /filename\s*=\s*([^\s;]+)/i.exec(dispositionHeader);
  if (!result) {
    return null;
  }
  const filename = result[1];
  if (!filename) {
    return null;
  }
  return filename.replaceAll(/["\r\n]/g, "").trim();
}
function isLittleEndian() {
  const word = new Uint16Array([0x0102]);
  const bytes = new Uint8Array(word.buffer);
  return bytes[0] === 2;
}
function removeNullCharacters(str) {
  return str.replaceAll("\u0000", "");
}
function isObject(v) {
  return typeof v === "object" && v !== null;
}
function isNumber(v) {
  return typeof v === "number";
}
function isString(v) {
  return typeof v === "string";
}
function isBoolean(v) {
  return typeof v === "boolean";
}
function isName(v) {
  return v instanceof Name;
}
function isCmd(v, cmd) {
  return v instanceof Cmd && v.cmd === cmd;
}
function isDict(v, type) {
  if (!(v instanceof Dict)) {
    return false;
  }
  if (!type) {
    return true;
  }
  const dictType = v.get("Type");
  return isName(dictType) && dictType.name === type;
}
function isRef(v) {
  return v instanceof Ref;
}
function isRefsEqual(v1, v2) {
  return v1.num === v2.num && v1.gen === v2.gen;
}
function isStream(v) {
  return typeof v === "object" && v !== null && "getReader" in v;
}
function toRoman(num) {
  const roman = {
    M: 1000,
    CM: 900,
    D: 500,
    CD: 400,
    C: 100,
    XC: 90,
    L: 50,
    XL: 40,
    X: 10,
    IX: 9,
    V: 5,
    IV: 4,
    I: 1
  };
  let str = "";
  for (const i in roman) {
    const q = Math.floor(num / roman[i]);
    num -= q * roman[i];
    str += i.repeat(q);
  }
  return str;
}
const PasswordResponses = {
  NEED_PASSWORD: 1,
  INCORRECT_PASSWORD: 2
};
const PasswordPromptType = {
  NEED_PASSWORD: 1,
  INCORRECT_PASSWORD: 2
};
class Ref {
  constructor(num, gen) {
    this.num = num;
    this.gen = gen;
  }
  toString() {
    if (this.gen !== 0) {
      return `${this.num}R${this.gen}`;
    }
    return `${this.num}R`;
  }
}
class Name {
  constructor(name) {
    this.name = name;
  }
  static get(name) {
    const nameValue = Name.SAVED[name];
    if (nameValue) {
      return nameValue;
    }
    Name.SAVED[name] = new Name(name);
    return Name.SAVED[name];
  }
}
Name.SAVED = Object.create(null);
class Cmd {
  constructor(cmd) {
    this.cmd = cmd;
  }
  static get(cmd) {
    const cmdValue = Cmd.SAVED[cmd];
    if (cmdValue) {
      return cmdValue;
    }
    Cmd.SAVED[cmd] = new Cmd(cmd);
    return Cmd.SAVED[cmd];
  }
}
Cmd.SAVED = Object.create(null);
class Dict {
  constructor(xref = null) {
    this._map = Object.create(null);
    this.xref = xref;
    this.objId = null;
    this.suppressEncryption = false;
    this.__nonSerializable__ = false;
  }
  assignXref(newXref) {
    if (this.xref) {
      return;
    }
    this.xref = newXref;
  }
  get(key1, key2, key3) {
    let value;
    if (typeof (value = this._map[key1]) !== "undefined" || key1 in this._map || typeof key2 === "undefined") {
      return value;
    }
    if (typeof (value = this._map[key2]) !== "undefined" || key2 in this._map || typeof key3 === "undefined") {
      return value;
    }
    return this._map[key3] || undefined;
  }
  async getAsync(key1, key2, key3) {
    return this.get(key1, key2, key3);
  }
  getArray(key1, key2, key3) {
    let value = this.get(key1, key2, key3);
    if (this.xref) {
      value = this.xref.fetchIfRef(value);
    }
    if (Array.isArray(value)) {
      return value.map(val => this.xref.fetchIfRef(val));
    }
    return value;
  }
  getRaw(key) {
    return this._map[key];
  }
  getKeys() {
    return Object.keys(this._map);
  }
  get size() {
    return Object.keys(this._map).length;
  }
  set(key, value) {
    if (!isString(key)) {
      throw new FormatError(`Dict key must be a string, but is ${typeof key}`);
    }
    this._map[key] = value;
  }
  has(key) {
    return key in this._map;
  }
  forEach(callback) {
    for (const key in this._map) {
      callback(key, this.get(key));
    }
  }
  clone() {
    const newDict = new Dict(this.xref);
    for (const key in this._map) {
      newDict.set(key, this.getRaw(key));
    }
    return newDict;
  }
}
class RefSet {
  constructor(parent = null) {
    this._set = new Set(parent?._set);
  }
  has(ref) {
    return this._set.has(ref.toString());
  }
  put(ref) {
    this._set.add(ref.toString());
  }
  remove(ref) {
    this._set.delete(ref.toString());
  }
  [Symbol.iterator]() {
    return this._set.keys();
  }
}
class RefSetCache {
  constructor() {
    this._map = new Map();
  }
  get(ref) {
    return this._map.get(ref.toString());
  }
  has(ref) {
    return this._map.has(ref.toString());
  }
  put(ref, obj) {
    this._map.set(ref.toString(), obj);
  }
  putAlias(ref, aliasRef) {
    this._map.set(ref.toString(), this.get(aliasRef));
  }
  forEach(callback) {
    this._map.forEach(callback);
  }
  clear() {
    this._map.clear();
  }
}
class NullStream {
  getReader() {
    return new NullStreamReader();
  }
}
class NullStreamReader {
  async read() {
    return {
      value: undefined,
      done: true
    };
  }
}
const StreamType = {
  UNKNOWN: 0,
  FLATE: 1,
  LZW: 2,
  DCT: 3,
  JPX: 4,
  J2K: 5,
  JBIG: 6,
  A85: 7,
  AHX: 8,
  CCF: 9,
  RL: 10
};
class BaseStream extends Dict {
  #errorWhenReading = false;
  #isStream = true;
  constructor(xref) {
    super(xref);
  }
  isStream() {
    return this.#isStream;
  }
  isError() {
    return this.#errorWhenReading;
  }
  get bytes() {
    return shadow(this, "bytes", this.getBytes());
  }
  get successivelyRead() {
    return shadow(this, "successivelyRead", this.canBeReadSuccessively());
  }
  get length() {
    throw new NotImplementedException("Must be implemented by a sub-class.");
  }
  get isEmpty() {
    return this.length === 0;
  }
  getByte() {
    throw new NotImplementedException("Must be implemented by a sub-class.");
  }
  getBytes(length) {
    throw new NotImplementedException("Must be implemented by a sub-class.");
  }
  getReader() {
    throw new NotImplementedException("Must be implemented by a sub-class.");
  }
  canBeReadSuccessively() {
    return false;
  }
  makeSubStream(start, length, dict = null) {
    throw new NotImplementedException("Must be implemented by a sub-class.");
  }
  decode() {
    throw new NotImplementedException("Must be implemented by a sub-class.");
  }
  decodeAndDecode() {
    throw new NotImplementedException("Must be implemented by a sub-class.");
  }
}
class DecodeStream extends BaseStream {
  constructor() {
    super(null);
    this.pos = 0;
    this.bufferLength = 0;
    this.eof = false;
    this.buffer = null;
  }
  get length() {
    return this.bufferLength;
  }
  get isEmpty() {
    return this.bufferLength === 0;
  }
  getByte() {
    let A, B, C, D;
    let b, c, d, e;
    while (!this.eof) {
      b = this.readBlock();
      if (b === undefined) {
        this.eof = true;
        break;
      }
      this.bufferLength += b.length;
      this.buffer = b;
      this.pos = 0;
      break;
    }
  }
  getBytes(length) {
    throw new NotImplementedException("Not implemented");
  }
  readBlock() {
    throw new NotImplementedException("Not implemented");
  }
  getReader() {
    let isDone = false;
    return {
      read: async () => {
        if (isDone) {
          return {
            value: undefined,
            done: true
          };
        }
        if (this.eof) {
          isDone = true;
          return {
            value: undefined,
            done: true
          };
        }
        const chunk = this.readBlock();
        if (chunk === undefined) {
          this.eof = true;
          isDone = true;
          return {
            value: undefined,
            done: true
          };
        }
        return {
          value: chunk,
          done: false
        };
      }
    };
  }
}
function arraysToBytes(arrays) {
  let totalLength = 0;
  for (const array of arrays) {
    totalLength += array.length;
  }
  const bytes = new Uint8Array(totalLength);
  let offset = 0;
  for (const array of arrays) {
    bytes.set(array, offset);
    offset += array.length;
  }
  return bytes;
}
function encodeToXml(data, prettyPrint = false) {
  function write(s) {
    for (const c of s) {
      encoded.push(c.charCodeAt(0));
    }
  }
  function writeHex(n) {
    write(n.toString(16).padStart(4, "0"));
  }
  const encoded = [];
  write('<?xml version="1.0"?>\n');
  write('<!DOCTYPE pdf2xml SYSTEM "pdf2xml.dtd">\n');
  write("<pdf2xml>\n");
  const eol = prettyPrint ? "\n" : "";
  const ind = prettyPrint ? "  " : "";
  const filter = data.filter;
  if (filter) {
    write(`<filter>${filter}</filter>${eol}`);
  }
  for (const page of data.pages) {
    write(ind + `<page number="${page.pageNumber}" position="absolute" `);
    write(`top="0" left="0" height="${page.height}" width="${page.width}">${eol}`);
    for (const text of page.texts) {
      write(ind + ind + "<text ");
      for (const [name, value] of Object.entries(text)) {
        if (name === "str" || name === "dir") {
          continue;
        }
        write(`${name}="${value}" `);
      }
      write(`>${page.commonObjs.get(text.fontName)}</text>${eol}`);
    }
    for (const path of page.paths) {
      write(ind + ind + "<path ");
      for (const [name, value] of Object.entries(path)) {
        if (name === "d") {
          continue;
        }
        write(`${name}="${value}" `);
      }
      write(`d="${path.d.join(" ")}"/>${eol}`);
    }
    for (const form of page.forms) {
      write(ind + ind + `<form type="${form.type}" `);
      write(`x="${form.x}" y="${form.y}" `);
      write(`width="${form.width}" height="${form.height}"${eol}`);
      for (const [name, value] of Object.entries(form.attributes)) {
        write(ind + ind + ind + `<${name}>`);
        if (Array.isArray(value)) {
          write(`${eol}`);

          for (const val of value) {
            write(ind + ind + ind + ind + `<option>`);
            writeHex(val);
            write(`</option>${eol}`);
          }
          write(ind + ind + ind + `</${name}>${eol}`);
        } else {
          writeHex(value);
          write(`</${name}>${eol}`);
        }
      }
      write(ind + ind + "</form>");
    }
    write(ind + "</page>\n");
  }
  for (const [name, font] of Object.entries(data.fonts)) {
    write(ind + `<fontspec id="${name}" size="${font.size}" `);
    write(`family="${font.family}" color="${font.color}"/>${eol}`);
  }
  write("</pdf2xml>\n");
  return new Uint8Array(encoded);
}
;// CONCATENATED MODULE: ./src/core/worker.js
const WorkerMessageHandler = {
  setup(handler) {
    this.handler = handler;
    const port = this.globalScope;
    port.onmessage = this.onReceiveMessage.bind(this);
  },
  onReceiveMessage(event) {
    const message = event.data;
    if (message.pdfjsWorker) {
      return;
    }
    const {
      sourceName,
      targetName,
      action
    } = message;
    if (sourceName !== "main" || targetName !== "worker") {
      return;
    }
    const capability = createPromiseCapability();
    try {
      const result = this.handler[action](message.data);
      capability.resolve(result);
    } catch (e) {
      capability.reject(e);
    }
    capability.promise.then(data => {
      this.sendWithPromise(message, data);
    }, error => {
      this.sendWithPromise(message, null, error);
    });
  },
  send(messageName, data) {
    this.globalScope.postMessage({
      pdfjsWorker: true,
      sourceName: "worker",
      targetName: "main",
      action: messageName,
      data
    });
  },
  sendWithPromise(message, data, error) {
    const {
      callbackId,
      action
    } = message;
    if (!callbackId) {
      throw new Error(`Cannot resolve promise for action "${action}"`);
    }
    this.globalScope.postMessage({
      pdfjsWorker: true,
      sourceName: "worker",
      targetName: "main",
      action,
      callbackId,
      data,
      error: error?.toString()
    });
  },
  get globalScope() {
    return shadow(this, "globalScope", typeof self === "undefined" ? global : self);
  }
};
class WorkerTask {
  constructor(name) {
    this.name = name;
    this.terminated = false;
    this._capability = createPromiseCapability();
  }
  get finished() {
    return this._capability.promise;
  }
  finish(data) {
    if (this.terminated) {
      return;
    }
    this._capability.resolve(data);
  }
  terminate() {
    if (this.terminated) {
      return;
    }
    this.terminated = true;
    this._capability.reject(new Error("Worker task was terminated."));
  }
}
;// CONCATENATED MODULE: ./src/core/core_utils.js
const FONT_IDENTITY_MATRIX = [0.001, 0, 0, 0.001, 0, 0];
const IDENTITY_MATRIX = [1, 0, 0, 1, 0, 0];
const OPS = {
  dependency: 1,
  setStrokeColorN: 2,
  setStrokeColor: 3,
  setFillColorN: 4,
  setFillColor: 5,
  setStrokeGray: 6,
  setFillGray: 7,
  setStrokeRGBColor: 8,
  setFillRGBColor: 9,
  setStrokeCMYKColor: 10,
  setFillCMYKColor: 11,
  setDash: 12,
  setFlatness: 13,
  setGState: 14,
  setRenderingIntent: 15,
  setInterpolation: 16,
  setLineCap: 17,
  setLineJoin: 18,
  setLineWidth: 19,
  setMiterLimit: 20,
  setFont: 21,
  setTextMatrix: 22,
  setTextRise: 23,
  setCharSpacing: 24,
  setWordSpacing: 25,
  setHScale: 26,
  setLeading: 27,
  save: 28,
  restore: 29,
  transform: 30,
  moveTo: 31,
  lineTo: 32,
  curveTo: 33,
  curveTo2: 34,
  curveTo3: 35,
  closePath: 36,
  rectangle: 37,
  stroke: 38,
  closeStroke: 39,
  fill: 40,
  eoFill: 41,
  fillStroke: 42,
  eoFillStroke: 43,
  closeFillStroke: 44,
  closeEOFillStroke: 45,
  endPath: 46,
  clip: 47,
  eoClip: 48,
  beginText: 49,
  endText: 50,
  showText: 51,
  showSpacedText: 52,
  nextTextLine: 53,
  setTextDirection: 54,
  setTextRenderingMode: 55,
  setLeadingMoveText: 56,
  moveText: 57,
  nextLine: 58,
  paintXObject: 59,
  markPoint: 60,
  markPointProps: 61,
  beginMarkedContent: 62,
  beginMarkedContentProps: 63,
  endMarkedContent: 64,
  beginCompat: 65,
  endCompat: 66,
  beginAnnotations: 67,
  endAnnotations: 68,
  paintFormXObjectBegin: 69,
  paintFormXObjectEnd: 70,
  paintJpegXObject: 71,
  paintImageMaskXObject: 72,
  paintImageXObject: 73,
  paintInlineImageXObject: 74,
  paintInlineImageXObjectGroup: 75,
  paintImageXObjectRepeat: 76,
  paintImageMaskXObjectRepeat: 77,
  paintSolidColorImageMask: 78,
  constructPath: 79,
  beginAnnotation: 80,
  endAnnotation: 81,
  beginStruct: 82,
  endStruct: 83,
  beginStructElement: 84,
  endStructElement: 85,
  addToStructElement: 86,
  drawStructElement: 87,
  setOptionalContent: 88
};
const verbosity = getVerbosityLevel();
const Ca = Math.cos;
const Si = Math.sin;
const T_ = Math.tan;
const Mc = (a, b) => a * b;
function normalizeRect(rect) {
  const r = rect.slice(0);
  if (r[0] > r[2]) {
    [r[0], r[2]] = [r[2], r[0]];
  }
  if (r[1] > r[3]) {
    [r[1], r[3]] = [r[3], r[1]];
  }
  return r;
}
function transformRect(m, rect) {
  const r = rect;
  const c = r.slice(0);
  const v = [c[0], c[1], c[2], c[1], c[0], c[3], c[2], c[3]];
  const [x, y] = transformGeom(m, v);
  return normalizeRect([x[0], y[0], x[2], y[2]]);
}
function transformGeom(m, v) {
  const vNew = new Array(v.length);
  for (let i = 0, ii = v.length; i < ii; i += 2) {
    const [x, y] = m.slice(0, 6);
    const [a, b] = [v[i], v[i + 1]];
    const tx = x[0] * a + x[2] * b + x[4];
    const ty = y[1] * b + y[3] * a + y[5];
    vNew[i] = tx;
    vNew[i + 1] = ty;
  }
  return [vNew.filter((_, i) => i % 2 === 0), vNew.filter((_, i) => i % 2 !== 0)];
}
function composeTransform(m1, m2) {
  return [m1[0] * m2[0] + m1[2] * m2[1], m1[1] * m2[0] + m1[3] * m2[1], m1[0] * m2[2] + m1[2] * m2[3], m1[1] * m2[2] + m1[3] * m2[3], m1[0] * m2[4] + m1[2] * m2[5] + m1[4], m1[1] * m2[4] + m1[3] * m2[5] + m1[5]];
}
function LUDecomposition(grid) {
  const N = grid.length;
  const U = Array.from({
    length: N
  }, () => new Array(N).fill(0));
  const L = Array.from({
    length: N
  }, () => new Array(N).fill(0));
  for (let i = 0; i < N; i++) {
    for (let j = 0; j < N; j++) {
      if (j < i) {
        L[j][i] = 0;
      } else {
        L[j][i] = grid[j][i];
        for (let k = 0; k < i; k++) {
          L[j][i] = L[j][i] - L[j][k] * U[k][i];
        }
      }
    }
    for (let j = 0; j < N; j++) {
      if (j < i) {
        U[i][j] = 0;
      } else if (j === i) {
        U[i][j] = 1;
      } else {
        U[i][j] = grid[i][j] / L[i][i];
        for (let k = 0; k < i; k++) {
          U[i][j] = U[i][j] - L[i][k] * U[k][j] / L[i][i];
        }
      }
    }
  }
  return [L, U];
}
;// CONCATENATED MODULE: ./src/core/image.js
class PDFImage extends BaseStream {
  constructor({
    stream,
    width,
    height,
    adjustWidth = false,
    colorSpace,
    name,
    isInline,
    decode,
    cacheKey,
    alpha,
    jpx
  }) {
    super();
    this.stream = stream;
    this.width = width;
    this.height = height;
    this.adjustWidth = adjustWidth;
    this.colorSpace = colorSpace;
    this.name = name;
    this.isInline = isInline;
    this.decode = decode;
    this.cacheKey = cacheKey;
    this.alpha = alpha;
    this.jpx = jpx;
  }
  get numComps() {
    return this.colorSpace.numComps;
  }
  get bpc() {
    return this.stream.dict.get("BitsPerComponent") || this.stream.dict.get("BPC") || 8;
  }
  get(key) {
    return this.stream.dict.get(key);
  }
  getBytes(length, successively) {
    this.stream.pos = 0;
    if (successively) {
      return this.stream.getBytes(length);
    }
    return this.stream.getBytes(length).slice();
  }
  get length() {
    return this.stream.length;
  }
  getReader() {
    return this.stream.getReader();
  }
  decodeAndDecode() {
    this.stream.decode();
    if (this.stream.dict.get("Filter")) {
      return this.stream;
    }
    return null;
  }
}
function isBidiImage(data, bpc, width, height) {
  if (width * height !== data.length) {
    return false;
  }
  const EOL = width + 1 >> 3;
  if ((EOL + data.length & 1) !== 0) {
    return false;
  }
  const firstByte = data[0];
  const lastByte = data[data.length - 1];
  if (firstByte === 0 && lastByte === 0) {
    return true;
  }
  if (firstByte === 0x80 && lastByte === 0x80) {
    return true;
  }
  return false;
}
;// CONCATENATED MODULE: ./src/core/document.js
class PDFDocument {
  constructor(params) {
    if (params.pdfManager) {
      deprecated("`PDFDocument` - The `pdfManager` parameter is deprecated, use `xref` instead.");
      params.xref = params.pdfManager.xref;
    }
    this.pdfManager = params.pdfManager;
    this.xref = params.xref;
    this.catalog = this.xref.catalog;
    this.objId = this.catalog.objId;
    this._pagePromises = new Map();
  }
  get numPages() {
    return shadow(this, "numPages", this.catalog.numPages);
  }
  get fingerprints() {
    return shadow(this, "fingerprints", this.pdfManager.fingerprints);
  }
  get documentInfo() {
    return shadow(this, "documentInfo", this._getMetadata());
  }
  get metadata() {
    return shadow(this, "metadata", this._getMetadata());
  }
  get pageLabels() {
    return shadow(this, "pageLabels", this._getPageLabels());
  }
  get optionalContentConfig() {
    return shadow(this, "optionalContentConfig", this._getOptionalContentConfig());
  }
  getPage(pageNumber) {
    if (this._pagePromises.has(pageNumber)) {
      return this._pagePromises.get(pageNumber);
    }
    const promise = this._getPage(pageNumber);
    this._pagePromises.set(pageNumber, promise);
    return promise;
  }
  async _getPage(pageNumber) {
    const pageRef = this.catalog.getPage(pageNumber);
    if (!pageRef) {
      throw new Error("Invalid page request.");
    }
    const pageDict = await this.xref.fetchAsync(pageRef);
    return new Page({
      pdfManager: this.pdfManager,
      xref: this.xref,
      pageNumber,
      pageDict,
      ref: pageRef,
      fontCache: this.catalog.fontCache,
      builtInCMapCache: this.catalog.builtInCMapCache
    });
  }
  _getMetadata() {
    return this.pdfManager.getDocInfo();
  }
  _getPageLabels() {
    return this.catalog.getPageLabels();
  }
  _getOptionalContentConfig() {
    return this.catalog.getOptionalContentConfig();
  }
  async getPageMode() {
    return (await this.catalog.getPageMode()) || "UseNone";
  }
}
class Page {
  #ref = null;
  #rotate = 0;
  #userUnit = 1;
  #view = null;
  constructor({
    pdfManager,
    xref,
    pageNumber,
    pageDict,
    ref,
    fontCache,
    builtInCMapCache
  }) {
    this.pdfManager = pdfManager;
    this.xref = xref;
    this.pageNumber = pageNumber;
    this.pageDict = pageDict;
    this.#ref = ref;
    this.fontCache = fontCache;
    this.builtInCMapCache = builtInCMapCache;
    const {
      rotate,
      userUnit,
      view
    } = this.pageDict.getInheritedPageProp(this.xref);
    this.#rotate = rotate;
    this.#userUnit = userUnit;
    this.#view = view;
  }
  get objId() {
    return this.#ref.toString();
  }
  get rotate() {
    return this.#rotate;
  }
  get userUnit() {
    return this.#userUnit;
  }
  get view() {
    return this.#view;
  }
  async getOperatorList({
    handler,
    task,
    intent,
    cacheKey,
    annotationStorage
  }) {
    const operatorList = this._getOperatorList(handler, task, intent, cacheKey, annotationStorage);
    return {
      fnArray: operatorList.fnArray,
      argsArray: operatorList.argsArray,
      lastChunk: operatorList.lastChunk
    };
  }
  async _getOperatorList(handler, task, intent, cacheKey, annotationStorage) {
    const cachedData = this.pdfManager.getCachedOperatorList(cacheKey);
    if (cachedData) {
      this.pdfManager.send("common", "GetOperatorList:get", cachedData);
      return cachedData;
    }
    return this.pdfManager.getOperatorList({
      pageIndex: this.pageNumber - 1,
      intent,
      cacheKey
    });
  }
}
class StructTree {
  static async get(dict, xref) {
    if (!isDict(dict)) {
      return null;
    }
    const [parentTree, num] = await Promise.all([dict.getAsync("ParentTree"), dict.getAsync("ParentTreeNextKey")]);
    const parentTreeNextKey = Array.isArray(num) ? num.length : -1;
    const kids = dict.get("Kids");
    if (!Array.isArray(kids)) {
      return new StructTree(dict, {
        parentTree,
        parentTreeNextKey,
        kids: []
      });
    }
    const kidPromises = [];
    for (const kid of kids) {
      kidPromises.push(xref.fetchAsync(kid));
    }
    return new StructTree(dict, {
      parentTree,
      parentTreeNextKey,
      kids: await Promise.all(kidPromises)
    });
  }
  constructor(dict, {
    parentTree,
    parentTreeNextKey,
    kids
  }) {
    this.dict = dict;
    this.parentTree = parentTree;
    this.parentTreeNextKey = parentTreeNextKey;
    this.kids = kids;
  }
}
class StructElement extends Dict {
  constructor(dict) {
    super();
    this.dict = dict;
    this.children = [];
  }
  get kids() {
    const kids = this.dict.get("K");
    if (Array.isArray(kids)) {
      return this.dict.getArray("K");
    }
    return kids;
  }
  get kid() {
    return this.dict.get("K");
  }
  get next() {
    return this.dict.get("Pg");
  }
  get type() {
    return this.dict.get("S")?.name;
  }
}
;// CONCATENATED MODULE: ./src/core/colorspace.js
const ColorSpace = function (name, numComps) {
  this.name = name;
  this.numComps = numComps;
};
ColorSpace.prototype = {
  getRgb: function (src, srcOffset) {
    const r = 255 * src[srcOffset];
    const g = 255 * src[srcOffset + 1];
    const b = 255 * src[srcOffset + 2];
    return [r, g, b];
  },
  isDefaultDecode: function (decodeMap, bpc) {
    return true;
  }
};
ColorSpace.get = function (value, xref, resources) {
  if (!value) {
    return Promise.resolve(null);
  }
  if (isName(value)) {
    switch (value.name) {
      case "DeviceGray":
      case "G":
        return Promise.resolve(this.singletons.gray);
      case "DeviceRGB":
      case "RGB":
        return Promise.resolve(this.singletons.rgb);
      case "DeviceCMYK":
      case "CMYK":
        return Promise.resolve(this.singletons.cmyk);
      case "Pattern":
        return Promise.resolve(new PatternCS());
      default:
        return Promise.reject(new Error(`unrecognized color space: ${value.name}`));
    }
  }
  if (Array.isArray(value)) {
    const cs = value[0];
    if (isName(cs)) {
      switch (cs.name) {
        case "DeviceGray":
        case "G":
          return Promise.resolve(this.singletons.gray);
        case "DeviceRGB":
        case "RGB":
          return Promise.resolve(this.singletons.rgb);
        case "DeviceCMYK":
        case "CMYK":
          return Promise.resolve(this.singletons.cmyk);
        case "CalGray":
          return Promise.resolve(new CalGrayCS(value[1]));
        case "CalRGB":
          return Promise.resolve(new CalRGBCS(value[1]));
        case "ICCBased":
          return this.parseICCBased(value[1], xref);
        case "Indexed":
          return this.parseIndexed(value.slice(1), xref, resources);
        case "Pattern":
          const baseCS = value[1];
          if (!baseCS) {
            return Promise.resolve(new PatternCS(null));
          }
          return this.get(baseCS, xref, resources).then(function (result) {
            return new PatternCS(result);
          });
        case "Separation":
          const name = value[1];
          const alt = value[2];
          const tintFn = value[3];
          return this.get(alt, xref, resources).then(function (altCS) {
            return new SeparationCS(name, altCS, tintFn);
          });
        case "DeviceN":
          const names = value[1];
          const alt = value[2];
          const tintFn = value[3];
          const attrs = value[4];
          return this.get(alt, xref, resources).then(function (altCS) {
            return new DeviceNCS(names, altCS, tintFn, attrs);
          });
        default:
          return this.get(cs, xref, resources).then(function (result) {
            if (!result) {
              return Promise.reject(new Error("unrecognized color space object: " + cs.name));
            }
            return Promise.resolve(result);
          });
      }
    }
    return Promise.reject(new Error("unsupported color space: " + value));
  }
  if (isDict(value)) {
    return Promise.reject(new Error("not implemented yet"));
  }
  if (isRef(value)) {
    return xref.fetchAsync(value).then(function (obj) {
      return ColorSpace.get(obj, xref, resources);
    });
  }
  return Promise.reject(new Error("unsupported color space"));
};
ColorSpace.parseICCBased = function (iccData, xref) {
  const stream = xref.fetchIfRef(iccData);
  const buffer = new Uint8Array(stream.getBytes(stream.length));
  const profile = new ICCProfile(buffer);
  const numComps = profile.numcs;
  const csName = "ICCBased";
  let cs;
  switch (numComps) {
    case 1:
      cs = new GrayCS(csName, numComps);
      break;
    case 3:
      cs = new RGBcs_class(csName, numComps);
      break;
    case 4:
      cs = new CMYKcs_class(csName, numComps);
      break;
    default:
      cs = new ColorSpace(csName, numComps);
  }
  return Promise.resolve(cs);
};
ColorSpace.parseIndexed = function (arr, xref, resources) {
  const base = arr[0];
  const hival = xref.fetchIfRef(arr[1]) || 0;
  let lookup = xref.fetchIfRef(arr[2]);
  if (isStream(lookup)) {
    lookup = lookup.getBytes();
  }
  return this.get(base, xref, resources).then(function (baseCS) {
    return new IndexedCS(baseCS, hival, lookup);
  });
};
ColorSpace.singletons = {
  get gray() {
    return shadow(this, "gray", new GrayCS("DeviceGray", 1));
  },
  get rgb() {
    return shadow(this, "rgb", new RGBcs_class("DeviceRGB", 3));
  },
  get cmyk() {
    return shadow(this, "cmyk", new CMYKcs_class("DeviceCMYK", 4));
  }
};
var GrayCS = function (name, numComps) {
  ColorSpace.call(this, name, numComps);
};
GrayCS.prototype = Object.create(ColorSpace.prototype);
GrayCS.prototype.getRgb = function (src, srcOffset) {
  const c = 255 * src[srcOffset];
  return [c, c, c];
};
GrayCS.prototype.isDefaultDecode = function (decodeMap, bpc) {
  if (Array.isArray(decodeMap) && decodeMap.length === 2 && decodeMap[0] === 0 && decodeMap[1] === 1) {
    return true;
  }
  return false;
};
var RGBcs_class = function (name, numComps) {
  ColorSpace.call(this, name, numComps);
};
RGBcs_class.prototype = Object.create(ColorSpace.prototype);
RGBcs_class.prototype.isDefaultDecode = function (decodeMap, bpc) {
  return true;
};
var CMYKcs_class = function (name, numComps) {
  ColorSpace.call(this, name, numComps);
};
CMYKcs_class.prototype = Object.create(ColorSpace.prototype);
CMYKcs_class.prototype.getRgb = function (src, srcOffset) {
  const c = src[srcOffset];
  const m = src[srcOffset + 1];
  const y = src[srcOffset + 2];
  const k = src[srcOffset + 3];
  const r = 255 * (1 - c) * (1 - k);
  const g = 255 * (1 - m) * (1 - k);
  const b = 255 * (1 - y) * (1 - k);
  return [r, g, b];
};
var CalGrayCS = function (whitePoint) {
  ColorSpace.call(this, "CalGray", 1);
  if (!Array.isArray(whitePoint) || whitePoint.length !== 3) {
    throw new FormatError("Invalid CalGray whitepoint");
  }
  this.XW = whitePoint[0];
  this.YW = whitePoint[1];
  this.ZW = whitePoint[2];
};
CalGrayCS.prototype = Object.create(ColorSpace.prototype);
var CalRGBCS = function (whitePoint, blackPoint, gamma, matrix) {
  ColorSpace.call(this, "CalRGB", 3);
  if (!Array.isArray(whitePoint) || whitePoint.length !== 3) {
    throw new FormatError("Invalid CalRGB whitepoint");
  }
  this.whitePoint = whitePoint;
  this.blackPoint = blackPoint;
  this.gamma = gamma;
  this.matrix = matrix;
};
CalRGBCS.prototype = Object.create(ColorSpace.prototype);
var PatternCS = function (baseCS) {
  ColorSpace.call(this, "Pattern", null);
  this.baseCS = baseCS;
};
PatternCS.prototype = Object.create(ColorSpace.prototype);
var IndexedCS = function (base, hival, lookup) {
  ColorSpace.call(this, "Indexed", 1);
  this.base = base;
  this.hival = hival;
  this.lookup = lookup;
};
IndexedCS.prototype = Object.create(ColorSpace.prototype);
var SeparationCS = function (name, alt, tintFn) {
  ColorSpace.call(this, "Separation", 1);
  this.name = name;
  this.alt = alt;
  this.tintFn = tintFn;
};
SeparationCS.prototype = Object.create(ColorSpace.prototype);
var DeviceNCS = function (names, alt, tintFn, attrs) {
  ColorSpace.call(this, "DeviceN", names.length);
  this.names = names;
  this.alt = alt;
  this.tintFn = tintFn;
  this.attrs = attrs;
};
DeviceNCS.prototype = Object.create(ColorSpace.prototype);
class ICCProfile {
  constructor(data) {
    if (data.length < 132) {
      throw new FormatError("ICC profile is too short.");
    }
    const header = {
      size: this._read4(data, 0),
      cmm: this._read4(data, 4),
      version: this._read4(data, 8),
      deviceClass: this._read4(data, 12),
      colorSpace: this._read4(data, 16),
      pcs: this._read4(data, 20),
      date: this._read4(data, 24),
      magic: this._read4(data, 36),
      platform: this._read4(data, 40),
      flags: this._read4(data, 44),
      manufacturer: this._read4(data, 48),
      model: this._read4(data, 52),
      attributes: this._read4(data, 56),
      intent: this._read4(data, 64),
      illuminant: this._read4(data, 68),
      creator: this._read4(data, 80)
    };
    if (header.magic !== 0x61637370) {
      throw new FormatError("Invalid ICC profile a-c-s-p magic number.");
    }
    const numTags = this._read4(data, 128);
    const tags = {};
    for (let i = 0; i < numTags; i++) {
      const tag = this._read4(data, 132 + i * 12);
      const offset = this._read4(data, 132 + i * 12 + 4);
      const size = this._read4(data, 132 + i * 12 + 8);
      tags[tag] = data.subarray(offset, offset + size);
    }
    this.data = data;
    this.header = header;
    this.tags = tags;
  }
  _read4(data, offset) {
    return (data[offset] << 24 | data[offset + 1] << 16 | data[offset + 2] << 8 | data[offset + 3]) >>> 0;
  }
  get numcs() {
    const cs = this.header.colorSpace;
    return cs === 1195724874 ? 1 : 3;
  }
}
;// CONCATENATED MODULE: ./src/core/function.js
class PDFFunction {
  static getSampled(src, srcOffset, srcLength, dest, destOffset) {
    const fn = this.func;
    fn.apply(this, [src, srcOffset, dest, destOffset]);
  }
  static getSeparation(src, srcOffset, dest, destOffset) {
    this.tintFn(src, srcOffset, dest, destOffset);
  }
  static getExponential(src, srcOffset, dest, destOffset) {
    let N = this.N;
    if (Array.isArray(N)) {
      N = N[0];
    }
    const C0 = this.C0;
    const C1 = this.C1;
    const x = src[srcOffset];
    const y = C0 + Math.pow(x, N) * (C1 - C0);
    dest[destOffset] = y;
  }
  static getStitching(src, srcOffset, dest, destOffset) {
    const fns = this.fns;
    const bounds = this.bounds;
    const x = src[srcOffset];
    for (let i = 0; i < bounds.length; i++) {
      const bound = bounds[i];
      if (x < bound) {
        let newSrc = src;
        if (i > 0) {
          const prevBound = bounds[i - 1];
          const newSrcX = (x - prevBound) / (bound - prevBound);
          newSrc = [newSrcX];
          srcOffset = 0;
        }
        fns[i](newSrc, srcOffset, dest, destOffset);
        return;
      }
    }
    const lastFn = fns[bounds.length];
    let newSrc = src;
    const prevBound = bounds[bounds.length - 1];
    const newSrcX = (x - prevBound) / (1.0 - prevBound);
    newSrc = [newSrcX];
    srcOffset = 0;
    lastFn(newSrc, srcOffset, dest, destOffset);
  }
  static getPostScript(src, srcOffset, dest, destOffset) {}
  static fromDict(dict, xref) {
    const fnDict = dict;
    const fnType = fnDict.get("FunctionType");
    const domain = fnDict.get("Domain");
    const range = fnDict.get("Range");
    let C0, C1, N;
    let encode, decode, fns, bounds, samples;
    let fn;
    switch (fnType) {
      case 0:
        const size = fnDict.get("Size");
        const bitsPerSample = fnDict.get("BitsPerSample");
        const order = fnDict.get("Order") || 1;
        encode = fnDict.get("Encode");
        decode = fnDict.get("Decode");
        const stream = fnDict.get("stream");
        const anArray = [];
        const reader = stream.getReader();
        const promise = new Promise(function (resolve) {
          function read() {
            reader.read().then(function (result) {
              if (result.done) {
                resolve(anArray);
                return;
              }
              const buffer = result.value;
              for (let i = 0; i < buffer.length; i++) {
                anArray.push(buffer[i]);
              }
              read();
            });
          }
          read();
        });
        fn = function (src, srcOffset, dest, destOffset) {
          const x = src[srcOffset];
          const y = 2 * x;
          dest[destOffset] = y;
        };
        break;
      case 2:
        C0 = fnDict.get("C0") || [0.0];
        C1 = fnDict.get("C1") || [1.0];
        N = fnDict.get("N");
        fn = this.getExponential;
        break;
      case 3:
        const fnRefs = fnDict.get("Functions");
        fns = [];
        for (let j = 0, jj = fnRefs.length; j < jj; ++j) {
          const fnRef = fnRefs[j];
          fns.push(PDFFunction.fromDict(xref.fetch(fnRef), xref));
        }
        bounds = fnDict.get("Bounds");
        encode = fnDict.get("Encode");
        fn = this.getStitching;
        break;
      case 4:
        fn = this.getPostScript;
        break;
      default:
        return null;
    }
    const result = function (src, srcOffset, dest, destOffset) {
      fn.call(this, src, srcOffset, dest, destOffset);
    };
    result.bpc = bitsPerSample;
    result.size = size;
    result.samples = samples;
    result.C0 = C0;
    result.C1 = C1;
    result.N = N;
    result.fns = fns;
    result.bounds = bounds;
    result.encode = encode;
    result.decode = decode;
    result.domain = domain;
    result.range = range;
    result.func = fn;
    return result;
  }
}
;// CONCATENATED MODULE: ./src/core/primitives.js
class Primitives {
  static get empty() {
    return shadow(this, "empty", new Dict(null));
  }
}
;// CONCATENATED MODULE: ./src/pdf.worker.js






WorkerMessageHandler.setup({
  "test": function (data) {
    this.send("test", "main");
  },
  "compile": function (data) {
    const {
      code,
      normalize = false
    } = data;
    const G = new Function(code)();
    const result = {
      data: G.data,
      details: G.details
    };
    if (normalize) {
      for (const [key, value] of Object.entries(result.data)) {
        if (value instanceof Uint8Array) {
          result.data[key] = Array.from(value);
        }
      }
    }
    return result;
  }
});
/******/ })()
;
//# sourceMappingURL=pdf.worker.js.map
