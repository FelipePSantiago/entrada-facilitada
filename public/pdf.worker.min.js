/* Copyright 2024 Mozilla Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

"use strict";

const pdfjsVersion = "4.2.67";
const pdfjsWorker = true;
/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ([
/* 0 */,
/* 1 */
/***/ ((__unused_webpack_module, exports) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.AbortException = exports.AnnotationError = exports.AnnotationParseException = exports.AssertionError = exports.FormatError = exports.InvalidPDFException = exports.MissingPDFException = exports.NotImplementedException = exports.NotSupportedException = exports.PasswordException = exports.PermissionException = exports.UnexpectedResponseException = exports.UnknownErrorException = exports.XRefEntryException = exports.XRefParseException = void 0;
class AbortException extends Error {
  constructor(message) {
    super(message);
    this.name = "AbortException";
  }
}
exports.AbortException = AbortException;
class AssertionError extends Error {
  constructor(message) {
    super(message);
    this.name = "AssertionError";
  }
}
exports.AssertionError = AssertionError;
class InvalidPDFException extends Error {
  constructor(message) {
    super(message);
    this.name = "InvalidPDFException";
  }
}
exports.InvalidPDFException = InvalidPDFException;
class MissingPDFException extends Error {
  constructor(message) {
    super(message);
    this.name = "MissingPDFException";
  }
}
exports.MissingPDFException = MissingPDFException;
class NotImplementedException extends Error {
  constructor(message) {
    super(message);
    this.name = "NotImplementedException";
  }
}
exports.NotImplementedException = NotImplementedException;
class NotSupportedException extends Error {
  constructor(message) {
    super(message);
    this.name = "NotSupportedException";
  }
}
exports.NotSupportedException = NotSupportedException;
class PasswordException extends Error {
  constructor(message, code) {
    super(message);
    this.name = "PasswordException";
    this.code = code;
  }
}
exports.PasswordException = PasswordException;
class PermissionException extends Error {
  constructor(message) {
    super(message);
    this.name = "PermissionException";
  }
}
exports.PermissionException = PermissionException;
class UnexpectedResponseException extends Error {
  constructor(message, status) {
    super(message);
    this.name = "UnexpectedResponseException";
    this.status = status;
  }
}
exports.UnexpectedResponseException = UnexpectedResponseException;
class UnknownErrorException extends Error {
  constructor(message, details) {
    super(message);
    this.name = "UnknownErrorException";
    this.details = details;
  }
}
exports.UnknownErrorException = UnknownErrorException;
class XRefEntryException extends Error {
  constructor(message) {
    super(message);
    this.name = "XRefEntryException";
  }
}
exports.XRefEntryException = XRefEntryException;
class XRefParseException extends Error {
  constructor(message) {
    super(message);
    this.name = "XRefParseException";
  }
}
exports.XRefParseException = XRefParseException;
class FormatError extends Error {
  constructor(message, details = null) {
    super(message);
    this.name = "FormatError";
    this.details = details;
  }
}
exports.FormatError = FormatError;
class AnnotationError extends Error {
  constructor(message, details = null) {
    super(message);
    this.name = "AnnotationError";
    this.details = details;
  }
}
exports.AnnotationError = AnnotationError;
class AnnotationParseException extends Error {
  constructor(message, details = null) {
    super(message);
    this.name = "AnnotationParseException";
    this.details = details;
  }
}
exports.AnnotationParseException = AnnotationParseException;

/***/ }),
/* 2 */
/***/ ((__unused_webpack_module, exports) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.stringToPDFName = exports.stringToBytes = exports.stringToUTF16HexString = exports.stringToUTF16String = exports.recoverJsURL = exports.isWhiteSpace = exports.numberToString = exports.numberToHex = exports.isNumber = exports.isName = exports.isString = exports.isSpace = exports.isHexDigit = exports.isDigit = exports.isBool = exports.getVerbosityLevel = exports.getLookupTableFactory = exports.getPDFFileNameFromURL = exports.createPromiseCapability = exports.createValidAbsoluteUrl = exports.bytesToString = void 0;
exports.warn = warn;
var private_utils = require("./private_utils.js");
const VerbosityLevel = {
  ERRORS: 0,
  WARNINGS: 1,
  INFOS: 5
};
let verbosity = VerbosityLevel.WARNINGS;
function getVerbosityLevel() {
  return verbosity;
}
function setVerbosityLevel(level) {
  verbosity = level;
}
function warn(msg) {
  if (verbosity >= VerbosityLevel.WARNINGS) {
    console.warn(msg);
  }
}
function createPromiseCapability() {
  let resolve, reject;
  const promise = new Promise((res, rej) => {
    resolve = res;
    reject = rej;
  });
  return {
    promise,
    resolve,
    reject
  };
}
exports.createPromiseCapability = createPromiseCapability;
function getPDFFileNameFromURL(url, defaultFilename = "document.pdf") {
  const reURI = /^(?:(?:[^:]+:)?\/\/[^/]+)?([^?#]*)(\?[^#]*)?(#.*)?$/;
  const reFilename = /[^/?#=]+\.pdf\b(?!.*\.pdf\b)/i;
  const splitURI = reURI.exec(url);
  let suggestedFilename = reFilename.exec(splitURI[1]) || reFilename.exec(splitURI[2]) || reFilename.exec(splitURI[3]);
  if (suggestedFilename) {
    suggestedFilename = suggestedFilename[0];
    if (suggestedFilename.includes("%")) {
      try {
        suggestedFilename = (0, private_utils.decodeURIComponent)(suggestedFilename);
      } catch (ex) {}
    }
  }
  return suggestedFilename || defaultFilename;
}
exports.getPDFFileNameFromURL = getPDFFileNameFromURL;
function isBool(v) {
  return typeof v === "boolean";
}
exports.isBool = isBool;
function isNumber(v) {
  return typeof v === "number";
}
exports.isNumber = isNumber;
function isString(v) {
  return typeof v === "string";
}
exports.isString = isString;
function isName(v) {
  return v instanceof Name;
}
exports.isName = isName;
const MAX_Array_LENGTH = 2 ** 30;
function isArray(v) {
  return Array.isArray(v);
}
function isArrayBuffer(v) {
  return v instanceof ArrayBuffer;
}
function isReadableStream(v) {
  return typeof v === "object" && v !== null && (0, private_utils.isObjectWithKey)(v, "getReader");
}
const IsLittleEndian = new Uint8Array(new Uint16Array([1]).buffer)[0] === 1;
function stringToBytes(str) {
  const length = str.length;
  const bytes = new Uint8Array(length);
  for (let i = 0; i < length; i++) {
    bytes[i] = str.charCodeAt(i) & 0xFF;
  }
  return bytes;
}
exports.stringToBytes = stringToBytes;
function bytesToString(bytes, start = 0, end = bytes.length) {
  let str = "";
  for (let i = start; i < end; i++) {
    str += String.fromCharCode(bytes[i]);
  }
  return str;
}
exports.bytesToString = bytesToString;
function stringToPDFName(str) {
  if (!str) {
    return "";
  }
  const length = str.length;
  let out = "";
  for (let i = 0; i < length; i++) {
    let c = str.charCodeAt(i);
    if (c >= 256) {
      c = 255;
    }
    if (c < 0x21 || c > 0x7E || c === 0x23 || c === 0x25 || c === 0x28 || c === 0x29 || c === 0x2F || c === 0x3C || c === 0x3E || c === 0x5B || c === 0x5D || c === 0x7B || c === 0x7D) {
      out += `#${(0, private_utils.numberToHex)(c, 2)}`;
    } else {
      out += str[i];
    }
  }
  return out;
}
exports.stringToPDFName = stringToPDFName;
const ESCAPED_PDF_NAME_REGEX = /#([0-9A-Fa-f]{2})/g;
const PDF_NAME_REPLACEMENT = (match, ...args) => String.fromCharCode(parseInt(args[0], 16));
function unescapePDFName(str) {
  return str.replace(ESCAPED_PDF_NAME_REGEX, PDF_NAME_REPLACEMENT);
}
function stringToUTF16String(str, bigEndian) {
  const length = str.length;
  const buf = [];
  for (let i = 0; i < length; ++i) {
    const code = str.charCodeAt(i);
    if (bigEndian) {
      buf.push(code >> 8, code & 0xFF);
    } else {
      buf.push(code & 0xFF, code >> 8);
    }
  }
  return String.fromCharCode.apply(null, buf);
}
exports.stringToUTF16String = stringToUTF16String;
function stringToUTF16HexString(str, bigEndian) {
  let hex = "<";
  const bom = bigEndian ? "FEFF" : "FFFE";
  for (let i = 0, ii = str.length; i < ii; i++) {
    const code = str.charCodeAt(i);
    const h = (0, private_utils.numberToHex)(code);
    hex += h.length < 4 ? "0".repeat(4 - h.length) + h : h;
  }
  return hex + ">";
}
exports.stringToUTF16HexString = stringToUTF16HexString;
function isSpace(ch) {
  return ch === 0x20 || ch === 0x09 || ch === 0x0D || ch === 0x0A;
}
exports.isSpace = isSpace;
function isWhiteSpace(ch) {
  return isSpace(ch) || ch === 0x00 || ch === 0x0C;
}
exports.isWhiteSpace = isWhiteSpace;
function isDigit(ch) {
  return ch >= 0x30 && ch <= 0x39;
}
exports.isDigit = isDigit;
function isHexDigit(ch) {
  return isDigit(ch) || ch >= 0x41 && ch <= 0x46 || ch >= 0x61 && ch <= 0x66;
}
exports.isHexDigit = isHexDigit;
const URL_SCHEMES = ["http", "https", "ftp", "mailto", "tel"];
function createValidAbsoluteUrl(url, baseUrl) {
  if (!url || typeof url !== "string") {
    return null;
  }
  if (baseUrl === null) {
    if (URL_SCHEMES.some(scheme => url.startsWith(scheme + ":"))) {
      return url;
    }
    return null;
  }
  try {
    return new URL(url, baseUrl).href;
  } catch (ex) {
    return null;
  }
}
exports.createValidAbsoluteUrl = createValidAbsoluteUrl;
function recoverJsURL(str) {
  const URL_REGEX = /^(?:http|https|ftp|mailto|tel):/i;
  if (URL_REGEX.test(str)) {
    return str;
  }
  const JS_URL_REGEX = /^(\s*\(?function\s*\((?:.|\s)*\)\s*\{(?:.|\s)*\})|(\s*.*\.exec(?:.|\s)*)/;
  const match = JS_URL_REGEX.exec(str);
  if (match) {
    return match[1] || match[2];
  }
  return null;
}
exports.recoverJsURL = recoverJsURL;
const IDENTITY_MATRIX = [1, 0, 0, 1, 0, 0];
const FONT_IDENTITY_MATRIX = [0.001, 0, 0, 0.001, 0, 0];
const PageViewport = function PageViewportClosure() {
  function PageViewport({
    viewBox,
    scale,
    rotation,
    offsetX = 0,
    offsetY = 0,
    dontFlip = false
  }) {
    this.viewBox = viewBox;
    this.scale = scale;
    this.rotation = rotation;
    this.offsetX = offsetX;
    this.offsetY = offsetY;
    const [x1, y1, x2, y2] = viewBox;
    this.width = Math.abs(x2 - x1);
    this.height = Math.abs(y2 - y1);
    if (dontFlip) {
      this.transform = [1, 0, 0, -1, -x1, y2];
    } else {
      this.transform = [1, 0, 0, -1, 0, this.height];
    }
    const transform = (0, private_utils.transformMatrix)(this.transform, [this.scale, 0, 0, this.scale, this.offsetX, this.offsetY]);
    switch (this.rotation % 360) {
      case 180:
        this.transform = (0, private_utils.transformMatrix)(transform, [-1, 0, 0, -1, this.width, this.height]);
        break;
      case 90:
        this.transform = (0, private_utils.transformMatrix)(transform, [0, 1, -1, 0, this.height, 0]);
        break;
      case 270:
        this.transform = (0, private_utils.transformMatrix)(transform, [0, -1, 1, 0, 0, this.width]);
        break;
    }
  }
  PageViewport.prototype = {
    clone: function ({
      scale = this.scale,
      rotation = this.rotation,
      offsetX = this.offsetX,
      offsetY = this.offsetY,
      dontFlip = false
    } = {}) {
      return new PageViewport({
        viewBox: this.viewBox.slice(),
        scale,
        rotation,
        offsetX,
        offsetY,
        dontFlip
      });
    },
    convertToViewportPoint: function (x, y) {
      return (0, private_utils.applyTransform)(this.transform, [x, y]);
    },
    convertToViewportRectangle: function (rect) {
      const [x1, y1] = this.convertToViewportPoint(rect[0], rect[1]);
      const [x2, y2] = this.convertToViewportPoint(rect[2], rect[3]);
      return [Math.min(x1, x2), Math.min(y1, y2), Math.max(x1, x2), Math.max(y1, y2)];
    },
    convertToPdfPoint: function (x, y) {
      return (0, private_utils.applyInverseTransform)(this.transform, [x, y]);
    }
  };
  return PageViewport;
}();
function getLookupTableFactory() {
  let lookupTables = Object.create(null);
  return function (generator) {
    const key = generator.toString();
    if (lookupTables[key]) {
      return lookupTables[key];
    }
    const table = generator();
    return lookupTables[key] = table;
  };
}
exports.getLookupTableFactory = getLookupTableFactory;
var _util = require("./util.js");
var Name = function NameClosure() {
  let nameCache = Object.create(null);
  function Name(name) {
    this.name = name;
  }
  Name.prototype = {};
  Name.get = function (name) {
    if (name) {
      const cached = nameCache[name];
      if (cached) {
        return cached;
      }
    }
    const newName = new Name(name);
    nameCache[name] = newName;
    return newName;
  };
  Name._clearCache = function () {
    nameCache = Object.create(null);
  };
  return Name;
}();
const numberToString = private_utils.numberToString;
exports.numberToString = numberToString;
const numberToHex = private_utils.numberToHex;
exports.numberToHex = numberToHex;

/***/ }),
/* 3 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.MissingDataException = exports.Parser = exports.Linearization = exports.Lexer = exports.ChunkedStream = void 0;
var _util = __webpack_require__(2);
var _core_utils = __webpack_require__(5);
var _primitives = __webpack_require__(4);
var _util2 = __webpack_require__(1);
var _stream = __webpack_require__(6);
class MissingDataException extends Error {
  constructor(begin, end) {
    super(`Missing data [${begin}, ${end})`);
    this.name = "MissingDataException";
    this.begin = begin;
    this.end = end;
  }
}
exports.MissingDataException = MissingDataException;
class ChunkedStream extends _stream.BaseStream {
  constructor(length, chunkSize, progressiveData) {
    super();
    this.length = length;
    this.chunkSize = chunkSize;
    this.progressiveData = progressiveData;
    this.chunks = [];
    this.numChunks = Math.ceil(length / chunkSize);
    this._loadedChunks = new Set();
  }
  getMissingChunks() {
    const missingChunks = [];
    for (let i = 0; i < this.numChunks; i++) {
      if (this._loadedChunks.has(i)) {
        continue;
      }
      missingChunks.push(i);
    }
    return missingChunks;
  }
  onReceiveData(begin, chunk) {
    const end = begin + chunk.length;
    const beginChunk = Math.floor(begin / this.chunkSize);
    const endChunk = Math.floor((end - 1) / this.chunkSize);
    for (let curChunk = beginChunk; curChunk <= endChunk; ++curChunk) {
      const curChunkBegin = curChunk * this.chunkSize;
      const curChunkEnd = Math.min(curChunkBegin + this.chunkSize, this.length);
      if (begin > curChunkBegin || end < curChunkEnd) {
        if (!this.chunks[curChunk]) {
          this.chunks[curChunk] = new Uint8Array(curChunkEnd - curChunkBegin);
        }
        const a = Math.max(0, begin - curChunkBegin);
        const b = Math.min(chunk.length, end - curChunkBegin);
        const c = Math.max(0, curChunkBegin - begin);
        this.chunks[curChunk].set(chunk.subarray(c, c + b - a), a);
      } else {
        this.chunks[curChunk] = chunk.length === this.chunkSize ? chunk : chunk.slice();
      }
      this._loadedChunks.add(curChunk);
    }
  }
  _getChunk(chunkId) {
    if (!this.chunks[chunkId]) {
      this.progressiveData({
        begin: chunkId * this.chunkSize,
        end: (chunkId + 1) * this.chunkSize
      });
      const begin = chunkId * this.chunkSize;
      const end = begin + this.chunkSize;
      throw new MissingDataException(begin, end);
    }
    return this.chunks[chunkId];
  }
  getByte() {
    const pos = this.pos;
    if (pos >= this.length) {
      return -1;
    }
    const chunkId = Math.floor(pos / this.chunkSize);
    const chunk = this._getChunk(chunkId);
    return chunk[pos % this.chunkSize];
  }
  getBytes(length) {
    const pos = this.pos;
    const len = this.length;
    if (pos >= len) {
      return null;
    }
    const n = Math.min(length, len - pos);
    const chunkId = Math.floor(pos / this.chunkSize);
    const chunk = this._getChunk(chunkId);
    const startInChunk = pos % this.chunkSize;
    const endInChunk = startInChunk + n;
    if (endInChunk <= this.chunkSize) {
      this.pos += n;
      return chunk.subarray(startInChunk, endInChunk);
    }
    const bytes = new Uint8Array(n);
    let bytesN = n;
    let i = 0;
    while (bytesN > 0) {
      const id = Math.floor(this.pos / this.chunkSize);
      const curChunk = this._getChunk(id);
      const start = this.pos % this.chunkSize;
      const lengthInChunk = Math.min(bytesN, this.chunkSize - start);
      bytes.set(curChunk.subarray(start, start + lengthInChunk), i);
      i += lengthInChunk;
      this.pos += lengthInChunk;
      bytesN -= lengthInChunk;
    }
    return bytes;
  }
  peekByte() {
    const byte = this.getByte();
    this.pos--;
    return byte;
  }
  peekBytes(length) {
    const bytes = this.getBytes(length);
    this.pos -= bytes ? bytes.length : 0;
    return bytes;
  }
  get a() {
    const n = this.peekBytes(4096);
    return (0, _util.bytesToString)(n);
  }
}
exports.ChunkedStream = ChunkedStream;
class Lexer {
  constructor(stream, handler) {
    this.stream = stream;
    this.handler = handler;
  }
  getObj() {
    let comment = false;
    let ch = this.stream.getByte();
    while (ch !== -1 && (0, _util.isWhiteSpace)(ch)) {
      ch = this.stream.getByte();
    }
    if (ch === -1) {
      return _primitives.EOF;
    }
    switch (ch) {
      case 0x25:
        comment = true;
        do {
          ch = this.stream.getByte();
        } while (ch !== -1 && ch !== 0x0A && ch !== 0x0D);
        while (ch !== -1 && (0, _util.isWhiteSpace)(ch)) {
          ch = this.stream.getByte();
        }
        if (ch === -1) {
          return _primitives.EOF;
        }
        if (comment && ch === 0x25) {
          if ((ch = this.stream.getByte()) === 0x25) {
            do {
              ch = this.stream.getByte();
            } while (ch !== -1 && ch !== 0x0A && ch !== 0x0D);
          }
        }
        return this.getObj();
      case 0x3C:
        ch = this.stream.getByte();
        if (ch === 0x3C) {
          this.stream.pos += 2;
          return _primitives.Dict.empty;
        }
        let str = "";
        let n = 0;
        let pos = this.stream.pos;
        while ((ch = this.stream.getByte()) !== -1 && ch !== 0x3E) {
          if (pos === this.stream.pos) {
            this.stream.pos++;
            pos++;
          }
          str += String.fromCharCode(ch);
          n++;
          if (n === 4096) {
            (0, _util.warn)("Lexer_getObj: Reading long string, buffer might be small.");
            n = 0;
          }
          pos = this.stream.pos;
        }
        if (ch === -1) {
          throw new _util2.FormatError("Unterminated hex string.");
        }
        this.stream.pos++;
        return _primitives.Cmd.get(str);
      case 0x28:
        return this.readString();
      case 0x2F:
        let name = "";
        while ((ch = this.stream.getByte()) !== -1 && !(0, _util.isWhiteSpace)(ch) && ch !== 0x28 && ch !== 0x29 && ch !== 0x3C && ch !== 0x3E && ch !== 0x5B && ch !== 0x5D && ch !== 0x7B && ch !== 0x7D && ch !== 0x2F && ch !== 0x25) {
          name += String.fromCharCode(ch);
        }
        if (ch !== -1) {
          this.stream.pos--;
        }
        return _primitives.Name.get(name);
      case 0x5B:
        return _primitives.Cmd.get("[");
      case 0x5D:
        return _primitives.Cmd.get("]");
      case 0x7B:
        return _primitives.Cmd.get("{");
      case 0x7D:
        return _primitives.Cmd.get("}");
    }
    if ((0, _util.isDigit)(ch) || ch === 0x2B || ch === 0x2D || ch === 0x2E) {
      let s = String.fromCharCode(ch);
      let sign = 1;
      if (ch === 0x2D) {
        sign = -1;
      } else if (ch === 0x2B) ; else {
        s = String.fromCharCode(ch);
      }
      ch = this.stream.getByte();
      while (ch !== -1 && (0, _util.isDigit)(ch)) {
        s += String.fromCharCode(ch);
        ch = this.stream.getByte();
      }
      if (ch === 0x2E) {
        s += String.fromCharCode(ch);
        ch = this.stream.getByte();
        while (ch !== -1 && (0, _util.isDigit)(ch)) {
          s += String.fromCharCode(ch);
          ch = this.stream.getByte();
        }
      }
      if (ch !== -1) {
        this.stream.pos--;
      }
      const value = parseFloat(s);
      if (isNaN(value)) {
        throw new _util2.FormatError(`Invalid number: ${s}`);
      }
      return value;
    }
    let command = String.fromCharCode(ch);
    while ((ch = this.stream.getByte()) !== -1 && !(0, _util.isWhiteSpace)(ch) && ch !== 0x28 && ch !== 0x29 && ch !== 0x3C && ch !== 0x3E && ch !== 0x5B && ch !== 0x5D && ch !== 0x7B && ch !== 0x7D && ch !== 0x2F && ch !== 0x25) {
      command += String.fromCharCode(ch);
    }
    if (ch !== -1) {
      this.stream.pos--;
    }
    const cmd = _primitives.Cmd.get(command);
    if (cmd !== undefined) {
      return cmd;
    }
    (0, _util.warn)(`Unknown command "${command}"`);
    return undefined;
  }
  readString() {
    let str = "";
    let bal = 1;
    let ch;
    while ((ch = this.stream.getByte()) !== -1 && bal > 0) {
      if (ch === 0x28) {
        bal++;
        str += "(";
      } else if (ch === 0x29) {
        bal--;
        if (bal > 0) {
          str += ")";
        }
      } else if (ch === 0x5C) {
        ch = this.stream.getByte();
        if (ch === -1) {
          break;
        }
        switch (ch) {
          case 0x6E:
            str += "\n";
            break;
          case 0x72:
            str += "\r";
            break;
          case 0x74:
            str += "\t";
            break;
          case 0x62:
            str += "\b";
            break;
          case 0x66:
            str += "\f";
            break;
          case 0x5C:
          case 0x28:
          case 0x29:
            str += String.fromCharCode(ch);
            break;
          case 0x0D:
            if (this.stream.peekByte() === 0x0A) {
              this.stream.pos++;
            }
            break;
          case 0x0A:
            break;
          default:
            if ((0, _util.isDigit)(ch)) {
              let octal = String.fromCharCode(ch);
              ch = this.stream.peekByte();
              if ((0, _util.isDigit)(ch)) {
                this.stream.pos++;
                octal += String.fromCharCode(ch);
                ch = this.stream.peekByte();
                if ((0, _util.isDigit)(ch)) {
                  this.stream.pos++;
                  octal += String.fromCharCode(ch);
                }
              }
              str += String.fromCharCode(parseInt(octal, 8));
            } else {
              str += String.fromCharCode(ch);
            }
            break;
        }
      } else {
        str += String.fromCharCode(ch);
      }
    }
    if (bal !== 0) {
      throw new _util2.FormatError("Unterminated string");
    }
    return str;
  }
}
exports.Lexer = Lexer;
class Parser {
  constructor({
    lexer,
    xref,
    handler,
    isEvalSupported = true
  }) {
    this.lexer = lexer;
    this.xref = xref;
    this.handler = handler;
    this.isEvalSupported = isEvalSupported;
    this.imageCache = Object.create(null);
  }
  getObj(cipherTransform = null) {
    const obj = this.lexer.getObj();
    if (!(0, _primitives.isRef)(obj)) {
      return obj;
    }
    return this.xref.fetch(obj, cipherTransform);
  }
}
exports.Parser = Parser;
class Linearization {
  constructor(stream) {
    this.parser = new Parser({
      lexer: new Lexer(stream),
      xref: null,
      isEvalSupported: false
    });
    this.length = this.parser.getObj();
    this.linDict = this.parser.getObj();
  }
  get number() {
    if ((0, _core_utils.isDict)(this.linDict) && this.linDict.has("Linearized")) {
      const linear = this.linDict.get("Linearized");
      if (typeof linear === "number") {
        return linear;
      }
    }
    return 0;
  }
}
exports.Linearization = Linearization;

/***/ }),
/* 4 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.isRef = exports.isRefLike = exports.isSpecialMethod = exports.isStream = exports.isRefsEqual = exports.isCmd = exports.isDict = exports.isEOF = exports.StreamType = exports.Stream = exports.Ref = exports.Dict = exports.Cmd = exports.EOF = void 0;
var _util = __webpack_require__(1);
var _util2 = __webpack_require__(2);
const EOF = Symbol("EOF");
exports.EOF = EOF;
class Cmd {
  constructor(cmd) {
    this.cmd = cmd;
  }
  static get(cmd) {
    const obj = this.dict[cmd];
    return obj || new Cmd(cmd);
  }
}
exports.Cmd = Cmd;
Cmd.dict = Object.create(null);
class Dict {
  constructor(xref = null) {
    this._map = Object.create(null);
    this.xref = xref;
    this.objId = null;
    this.suppressEncryption = false;
    this.__nonSerializable__ = true;
  }
  assignXref(newXref) {
    this.xref = newXref;
  }
  get size() {
    return Object.keys(this._map).length;
  }
  get(key) {
    return this._map[key];
  }
  getAll() {
    return this._map;
  }
  getArray(key) {
    const obj = this._map[key];
    if (Array.isArray(obj)) {
      return obj;
    }
    return undefined;
  }
  getAsync(key) {
    return this.xref.fetchAsync(this.get(key));
  }
  getRaw(key) {
    return this._map[key];
  }
  getKeys() {
    return Object.keys(this._map);
  }
  has(key) {
    return this._map[key] !== undefined;
  }
  set(key, value) {
    if (key === undefined || key === "__proto__" || key === "constructor" || typeof key.valueOf() !== "string") {
      throw new Error("Invalid key for Dict");
    }
    this._map[key] = value;
  }
  delete(key) {
    delete this._map[key];
  }
  forEach(callback) {
    for (const key in this._map) {
      callback(key, this.get(key));
    }
  }
  [Symbol.iterator]() {
    return this.getKeys().map(key => [key, this.get(key)])[Symbol.iterator]();
  }
  static get empty() {
    const emptyDict = new Dict();
    Object.defineProperty(this, "empty", {
      value: emptyDict,
      enumerable: true,
      configurable: true,
      writable: false
    });
    return emptyDict;
  }
}
exports.Dict = Dict;
class Ref {
  constructor(num, gen) {
    this.num = num;
    this.gen = gen;
    this.__nonSerializable__ = true;
  }
  toString() {
    if (this.gen === 0) {
      return `${this.num}R`;
    }
    return `${this.num}R${this.gen}`;
  }
  static get(num, gen) {
    return new Ref(num, gen);
  }
}
exports.Ref = Ref;
let streamNextId = 1;
const StreamType = {
  UNKNOWN: 0,
  FLATE: 1,
  LZW: 2,
  DCT: 3,
  JPX: 4,
  J2K: 5,
  CCF: 6,
  A85: 7
};
exports.StreamType = StreamType;
class Stream {
  constructor(arrayBuffer, start, length, dict) {
    this.arrayBuffer = arrayBuffer;
    this.start = start;
    this.pos = start;
    this.end = start + length;
    this.dict = dict;
    this.str = null;
    this.progressive = false;
    this.filesize = 0;
    this.type = StreamType.UNKNOWN;
    Object.defineProperty(this, "id", {
      value: `str_${streamNextId++}`
    });
  }
  get length() {
    return this.end - this.start;
  }
  get isEmpty() {
    return this.length === 0;
  }
  get canBeResolved() {
    return this.str === null || this.str instanceof _stream.DecodeStream;
  }
  get isResolved() {
    return this.str !== null && !(this.str instanceof _stream.DecodeStream);
  }
  get isDataLoaded() {
    return true;
  }
  get kind() {
    return "Stream";
  }
  get stream() {
    return this.str;
  }
  set stream(str) {
    if (this.str !== null) {
      throw new _util.AssertionError("Cannot set a stream twice.");
    }
    this.str = str;
  }
  get hasParams() {
    const params = this.dict.get("DecodeParms") || this.dict.get("DP");
    return (0, _primitives.isDict)(params);
  }
  get canAsyncDecode() {
    return this.type !== StreamType.LZW;
  }
  get isAsync() {
    const str = this.str;
    if (!(str instanceof _stream.DecodeStream)) {
      return false;
    }
    return str.isAsync;
  }
  getByte() {
    if (this.pos >= this.end) {
      return -1;
    }
    return this.arrayBuffer[this.pos++];
  }
  getBytes(length) {
    const e = this.end;
    let n = length;
    if (n === undefined) {
      if (e === undefined) {
        return null;
      }
      n = e - this.pos;
    }
    if (this.pos >= e) {
      return null;
    }
    const bytes = this.arrayBuffer.subarray(this.pos, this.pos + n);
    this.pos += bytes.length;
    return bytes;
  }
  peekBytes(length) {
    const bytes = this.getBytes(length);
    if (bytes) {
      this.pos -= bytes.length;
    }
    return bytes;
  }
  peekByte() {
    const byte = this.getByte();
    this.pos--;
    return byte;
  }
  decode() {
    if (this.str === null) {
      throw new Error("Decoding is not initialized.");
    }
    if (this.isResolved) {
      return;
    }
    const str = this.str;
    if (str.isAsync) {
      throw new _util.AssertionError("Cannot use `decode` with an async stream.");
    }
    str.decode();
  }
  decodeAsync() {
    if (this.str === null) {
      throw new Error("Decoding is not initialized.");
    }
    if (this.isResolved) {
      return Promise.resolve();
    }
    const str = this.str;
    if (!str.isAsync) {
      throw new _util.AssertionError("Cannot use `decodeAsync` with a non-async stream.");
    }
    return str.decodeAsync();
  }
  reset() {
    this.pos = this.start;
  }
  moveStart() {
    this.start = this.pos;
  }
  makeSubStream(start, length, dict = this.dict) {
    return new Stream(this.arrayBuffer, start, length, dict);
  }
}
exports.Stream = Stream;
function isEOF(v) {
  return v === EOF;
}
exports.isEOF = isEOF;
function isCmd(v, cmd) {
  return v instanceof Cmd && (cmd === undefined || v.cmd === cmd);
}
exports.isCmd = isCmd;
function isDict(v, type) {
  return v instanceof Dict && (type === undefined || isName(v.get("Type"), type));
}
exports.isDict = isDict;
function isRef(v) {
  return v instanceof Ref;
}
exports.isRef = isRef;
function isRefLike(v) {
  return v instanceof Ref || isDict(v) && v.objId !== null;
}
exports.isRefLike = isRefLike;
function isRefsEqual(ref1, ref2) {
  return ref1.num === ref2.num && ref1.gen === ref2.gen;
}
exports.isRefsEqual = isRefsEqual;
function isStream(v) {
  return typeof v === "object" && v !== null && v.kind === "Stream";
}
exports.isStream = isStream;
function isSpecialMethod(v) {
  return v instanceof Cmd && v.cmd.startsWith("g_");
}
exports.isSpecialMethod = isSpecialMethod;
var _primitives = require("./primitives.js");
var _stream = require("./stream.js");

/***/ }),
/* 5 */
/***/ ((__unused_webpack_module, exports) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.toRoman = exports.parseXFAPath = exports.parseXFADataname = exports.isAscii = exports.escapePDFString = exports.decodePDFString = exports.decodeString = exports.decodeDate = void 0;
exports.warn = warn;
const ROMAN_NUMBER_MAP = {
  M: 1000,
  CM: 900,
  D: 500,
  CD: 400,
  C: 100,
  XC: 90,
  L: 50,
  XL: 40,
  X: 10,
  IX: 9,
  V: 5,
  IV: 4,
  I: 1
};
function toRoman(num, lowerCase = false) {
  if (!Number.isInteger(num) || num <= 0) {
    warn(`toRoman: The number must be a positive integer, got "${num}".`);
    return "";
  }
  if (num >= 4000) {
    warn(`toRoman: The number must be less than 4000, got "${num}".`);
    return "";
  }
  const roman = Object.entries(ROMAN_NUMBER_MAP).reduce((acc, [key, value]) => {
    while (num >= value) {
      num -= value;
      acc += key;
    }
    return acc;
  }, "");
  return lowerCase ? roman.toLowerCase() : roman;
}
exports.toRoman = toRoman;
function decodeString(bytes) {
  if (bytes.length >= 2 && bytes[0] === 0xFE && bytes[1] === 0xFF) {
    let str = "";
    for (let i = 2; i < bytes.length; i += 2) {
      str += String.fromCharCode(bytes[i] << 8 | bytes[i + 1]);
    }
    return str;
  }
  let str = "";
  for (let i = 0; i < bytes.length; i++) {
    str += String.fromCharCode(bytes[i]);
  }
  return str;
}
exports.decodeString = decodeString;
function decodeDate(date) {
  if (!/^D:(\d{4})(\d{2})?(\d{2})?(\d{2})?(\d{2})?(\d{2})?([Z+-])?(\d{2})?'?(\d{2})?'?$/.test(date)) {
    return null;
  }
  const D = date.substring(2);
  const M = [1, D.substring(0, 4), D.substring(4, 6) || "01", D.substring(6, 8) || "01", D.substring(8, 10) || "00", D.substring(10, 12) || "00", D.substring(12, 14) || "00"];
  M[2] = parseInt(M[2], 10) - 1;
  const UT = D.substring(14, 15);
  if (UT === "Z") {
    return new Date(Date.UTC(M[1], M[2], M[3], M[4], M[5], M[6]));
  }
  let UToffset = 0;
  if (UT === "+" || UT === "-") {
    const s = UT === "-" ? -1 : 1;
    const h = parseInt(D.substring(15, 17), 10) || 0;
    const m = parseInt(D.substring(18, 20), 10) || 0;
    UToffset = s * (h * 60 + m);
  }
  const d = new Date(M[1], M[2], M[3], M[4], M[5], M[6]);
  return new Date(d.getTime() - (d.getTimezoneOffset() - UToffset) * 60000);
}
exports.decodeDate = decodeDate;
function decodePDFString(str) {
  if (str.length >= 2 && str.charCodeAt(0) === 0xFE && str.charCodeAt(1) === 0xFF) {
    let str2 = "";
    for (let i = 2; i < str.length; i += 2) {
      str2 += String.fromCharCode(str.charCodeAt(i) << 8 | str.charCodeAt(i + 1));
    }
    return str2;
  }
  return str;
}
exports.decodePDFString = decodePDFString;
function escapePDFString(str) {
  const higher = str.split("").reduce((acc, char) => acc + (char.charCodeAt(0) > 127 ? 1 : 0), 0);
  const canBeAscii = higher === 0;
  let r = "";
  for (const char of str) {
    const charCode = char.charCodeAt(0);
    switch (charCode) {
      case 0x08:
        r += "\\b";
        continue;
      case 0x09:
        r += "\\t";
        continue;
      case 0x0A:
        r += "\\n";
        continue;
      case 0x0C:
        r += "\\f";
        continue;
      case 0x0D:
        r += "\\r";
        continue;
      case 0x28:
      case 0x29:
      case 0x5C:
        r += `\\${char}`;
        continue;
    }
    if (canBeAscii) {
      if (charCode < 0x20 || charCode > 0x7E) {
        r += `\\${charCode.toString(8).padStart(3, "0")}`;
      } else {
        r += char;
      }
      continue;
    }
    r += `\\${charCode.toString(8).padStart(3, "0")}`;
  }
  return `(${r})`;
}
exports.escapePDFString = escapePDFString;
const XFAPath = {
  $nodeName(node, pos, ns, isQualified) {
    if (!node) {
      return "";
    }
    const nodeName = node.nodeName;
    if (isQualified && ns !== -1 && node.namespaceId === ns) {
      return nodeName;
    }
    const i = nodeName.indexOf(":");
    if (i === -1) {
      return nodeName;
    }
    if (ns === -1 || node.namespaceId === ns) {
      return nodeName.substring(i + 1);
    }
    return "";
  },
  $nodePosition(node, name) {
    let i = 1;
    let prev = node.previousSibling;
    while (prev) {
      if (prev.nodeName === name) {
        i++;
      }
      prev = prev.previousSibling;
    }
    return i;
  },
  $build(node) {
    if (!node) {
      return "";
    }
    const name = node.nodeName;
    const pos = XFAPath.$nodePosition(node, name);
    let path = `${name}[${pos - 1}]`;
    let parent = node.parentNode;
    while (parent && parent.nodeType === 1 && parent.nodeName !== "#document") {
      const pName = parent.nodeName;
      const pPos = XFAPath.$nodePosition(parent, pName);
      path = `${pName}[${pPos - 1}].${path}`;
      parent = parent.parentNode;
    }
    return path;
  }
};
function parseXFAPath(path) {
  const FN_RE = /^([A-Za-z_]+)\((.*)\)$/;
  const pathArray = [];
  const nodes = path.split(".");
  for (const node of nodes) {
    const match = node.match(/^([A-Za-z0-9_:]+)(?:\[(\d+)\])?$/);
    if (!match) {
      throw new Error(`Invalid XFA path: ${path}`);
    }
    pathArray.push({
      name: match[1],
      pos: match[2] ? parseInt(match[2], 10) : 0
    });
  }
  return pathArray;
}
exports.parseXFAPath = parseXFAPath;
function parseXFADataname(path) {
  let [name, ...remainder] = path.split(".");
  name = name.replace(/\[\d+\]$/, "");
  const pos = parseInt(path.match(/\[(\d+)\]$/)?.[1] ?? "0", 10);
  return {
    name,
    pos,
    remainder: remainder.join(".")
  };
}
exports.parseXFADataname = parseXFADataname;
function isAscii(str) {
  return /^[\x00-\x7F]*$/.test(str);
}
exports.isAscii = isAscii;

/***/ }),
/* 6 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.StreamsSequenceStream = exports.StreamReader = exports.DecodeStream = exports.BaseStream = void 0;
var _util = __webpack_require__(2);
var _util2 = __webpack_require__(1);
var _primitives = __webpack_require__(4);
class BaseStream {
  constructor() {
    this._waitingForMoreData = false;
    this.pos = 0;
    this.start = 0;
  }
  get length() {
    (0, _util2.unreachable)("Abstract getter `length` not implemented.");
  }
  get isEmpty() {
    return this.length === 0;
  }
  getByte() {
    (0, _util2.unreachable)("Abstract method `getByte` not implemented.");
  }
  getBytes(length) {
    (0, _util2.unreachable)("Abstract method `getBytes` not implemented.");
  }
  peekBytes(length) {
    const bytes = this.getBytes(length);
    this.pos -= bytes ? bytes.length : 0;
    return bytes;
  }
  peekByte() {
    const byte = this.getByte();
    if (byte !== -1) {
      this.pos--;
    }
    return byte;
  }
  get isDataLoaded() {
    return true;
  }
  async asyncGetBytes(length) {
    return this.getBytes(length);
  }
  get canAsyncDecode() {
    return false;
  }
  get isAsync() {
    return false;
  }
  reset() {
    this.pos = 0;
  }
  moveStart() {
    this.start = this.pos;
  }
  makeSubStream(start, length, dict = null) {
    (0, _util2.unreachable)("Abstract method `makeSubStream` not implemented.");
  }
  ensureNotWaiting() {
    this._waitingForMoreData = false;
  }
  onReceiveData(begin, chunk) {
    (0, _util2.unreachable)("Abstract method `onReceiveData` not implemented.");
  }
}
exports.BaseStream = BaseStream;
class DecodeStream extends BaseStream {
  constructor(str) {
    super();
    this.str = str;
    this.buffer = null;
    this.bufferLength = 0;
    this.eof = false;
  }
  get length() {
    return this.bufferLength;
  }
  get isEmpty() {
    return this.bufferLength === 0 && this.eof;
  }
  get canAsyncDecode() {
    if (!this.str.canAsyncDecode) {
      return false;
    }
    const dict = this.str.dict;
    const filter = dict.get("Filter", "F");
    const filterName = (0, _primitives.isName)(filter) ? filter.name : Array.isArray(filter) && (0, _primitives.isName)(filter[0]) ? filter[0].name : "";
    return filterName !== "LZWDecode" && filterName !== "LZW";
  }
  get isAsync() {
    return this.str.isAsync;
  }
  readBlock() {
    (0, _util2.unreachable)("Abstract method `readBlock` not implemented.");
  }
  decode() {
    this.ensureNotWaiting();
    while (!this.eof) {
      this.readBlock();
    }
    this.str.reset();
  }
  async decodeAsync() {
    this.ensureNotWaiting();
    while (!this.eof) {
      await this.readBlock();
    }
    this.str.reset();
  }
  getByte() {
    if (this.pos >= this.bufferLength) {
      if (this.eof) {
        return -1;
      }
      this.readBlock();
      if (this.pos >= this.bufferLength) {
        return -1;
      }
    }
    return this.buffer[this.pos++];
  }
  getBytes(length) {
    const n = length;
    const bufferLength = this.bufferLength;
    let pos = this.pos;
    if (n > bufferLength - pos) {
      do {
        if (this.eof) {
          const sub = this.buffer.subarray(pos, bufferLength);
          this.pos = bufferLength;
          return sub;
        }
        this.readBlock();
      } while (n > this.bufferLength - pos);
    }
    const sub = this.buffer.subarray(pos, pos + n);
    this.pos = pos + n;
    return sub;
  }
  reset() {
    this.pos = 0;
  }
  makeSubStream(start, length, dict = null) {
    if (this.isAsync) {
      (0, _util2.unreachable)("Cannot use `makeSubStream` with an async stream.");
    }
    this.ensureNotWaiting();
    while (this.bufferLength < start + length && !this.eof) {
      this.readBlock();
    }
    return new Stream(this.buffer, start, length, dict);
  }
}
exports.DecodeStream = DecodeStream;
class StreamsSequenceStream extends BaseStream {
  constructor(streams) {
    super();
    this.streams = streams;
  }
  get length() {
    let length = 0;
    for (const stream of this.streams) {
      length += stream.length;
    }
    return length;
  }
  getByte() {
    if (!this.streams.length) {
      return -1;
    }
    let byte = this.streams[0].getByte();
    while (byte === -1 && this.streams.length > 1) {
      this.streams.shift();
      byte = this.streams[0].getByte();
    }
    return byte;
  }
  getBytes(length) {
    const bytes = new Uint8Array(length);
    let bytesRead = 0;
    while (bytesRead < length && this.streams.length) {
      const newBytes = this.streams[0].getBytes(length - bytesRead);
      bytes.set(newBytes, bytesRead);
      bytesRead += newBytes.length;
      if (this.streams[0].length === 0) {
        this.streams.shift();
      }
    }
    return bytes.subarray(0, bytesRead);
  }
  reset() {
    (0, _util2.unreachable)("The `reset` method is not implemented.");
  }
}
exports.StreamsSequenceStream = StreamsSequenceStream;
class StreamReader {
  constructor(stream) {
    this.stream = stream;
    this.pos = 0;
    this.end = stream.end;
    this.bytes = stream.getBytes();
    this.stream = null;
  }
  get length() {
    return this.bytes.length;
  }
  get eof() {
    return this.pos >= this.end;
  }
  getByte() {
    if (this.pos >= this.end) {
      return -1;
    }
    return this.bytes[this.pos++];
  }
  get twoBytes() {
    if (this.pos + 1 >= this.end) {
      return -1;
    }
    const b1 = this.bytes[this.pos++];
    const b2 = this.bytes[this.pos++];
    return b1 << 8 | b2;
  }
  get fourBytes() {
    if (this.pos + 3 >= this.end) {
      return -1;
    }
    const b1 = this.bytes[this.pos++];
    const b2 = this.bytes[this.pos++];
    const b3 = this.bytes[this.pos++];
    const b4 = this.bytes[this.pos++];
    return (b1 << 24 | b2 << 16 | b3 << 8 | b4) >>> 0;
  }
  getBytes(length) {
    if (this.pos + length > this.end) {
      return null;
    }
    const bytes = this.bytes.subarray(this.pos, this.pos + length);
    this.pos += length;
    return bytes;
  }
  peekByte() {
    if (this.pos >= this.end) {
      return -1;
    }
    return this.bytes[this.pos];
  }
  peekBytes(length) {
    if (this.pos + length > this.end) {
      return null;
    }
    return this.bytes.subarray(this.pos, this.pos + length);
  }
  skip(n) {
    this.pos += n;
  }
  reset() {
    this.pos = 0;
  }
}
exports.StreamReader = StreamReader;
var _stream = require("./stream.js");

/***/ }),
/* 7 */
/***/ ((__unused_webpack_module, exports) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.JpxImage = void 0;
function JpxImage() {
  this.width = 0;
  this.height = 0;
  this.componentsCount = 0;
  this.tiles = [];
  this.imageData = null;
}
JpxImage.prototype = {
  parse(data) {
    const handler = new JpxImage.Handler();
    let jpxImage = null;
    try {
      jpxImage = handler.parse(data, {
        pdfjsJpxDecoder: true
      });
    } catch (e) {
      console.log(`JPX indexing failed -- trying to recover: ${e}`);
      jpxImage = handler.parse(data, {
        pdfjsJpxDecoder: false
      });
    }
    this.width = jpxImage.width;
    this.height = jpxImage.height;
    this.componentsCount = jpxImage.componentsCount;
    const bitdepth = jpxImage.bitsPerComponent;
    if (bitdepth !== 8) {
      console.log(`Unsupported bit depth: ${bitdepth}`);
      return;
    }
    this.tiles = jpxImage.tiles;
    if (this.tiles.length === 0) {
      return;
    }
    this.imageData = new Uint8ClampedArray(this.width * this.height * this.componentsCount);
    let i = 0;
    for (const tile of this.tiles) {
      const data = tile.items;
      const dataLength = data.length;
      for (let j = 0; j < dataLength; j++) {
        this.imageData[i++] = data[j];
      }
    }
  },
  get isAlpha() {
    return this.componentsCount > 3;
  }
};
const globalScope = function () {
  return typeof window === "undefined" ? global : window;
}();
if (globalScope.jpxImage) {
  JpxImage.Handler = globalScope.jpxImage.Handler;
}
exports.JpxImage = JpxImage;

/***/ }),
/* 8 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.WorkerMessageHandler = exports.WorkerTask = void 0;
var _util = __webpack_require__(1);
var _util2 = __webpack_require__(2);
var _jpx = __webpack_require__(7);
var _primitives = __webpack_require__(4);
var _image_utils = __webpack_require__(9);
class WorkerTask {
  constructor(name) {
    this._name = name;
    this._transport = null;
    this._capability = (0, _util2.createPromiseCapability)();
    this._isDirty = true;
    this._data = null;
  }
  get name() {
    return this._name;
  }
  get isDirty() {
    return this._isDirty;
  }
  set isDirty(val) {
    this._isDirty = val;
  }
  get data() {
    return this._data;
  }
  set data(val) {
    this._data = val;
  }
  get transport() {
    return this._transport;
  }
  set transport(val) {
    this._transport = val;
  }
  get capability() {
    return this._capability;
  }
  _send(data, transfers) {
    if (this._transport) {
      this._transport.postMessage(data, transfers);
    }
  }
  finish() {
    this._capability.resolve();
  }
  send(data, transfers) {
    this._send(data, transfers);
    this.finish();
  }
  resolve(data) {
    this.isDirty = false;
    this.send({
      pdfjsWorker: true,
      jobId: this._name,
      action: "resolve",
      data
    });
  }
  reject(reason) {
    let message;
    if (reason instanceof Error) {
      message = reason.message;
    } else if (typeof reason === "string") {
      message = reason;
    } else {
      message = "Unknown reason.";
    }
    const name = reason.name;
    const details = reason.details;
    this.isDirty = false;
    this.send({
      pdfjsWorker: true,
      jobId: this._name,
      action: "reject",
      data: {
        message,
        name,
        details
      }
    });
  }
  request(action, data) {
    const message = {
      pdfjsWorker: true,
      jobId: this._name,
      action,
      data
    };
    this.isDirty = false;
    this.send(message);
    return this._capability.promise;
  }
}
exports.WorkerTask = WorkerTask;
const WorkerMessageHandler = {
  setup(handler, port) {
    let testMessageProcessed = false;
    handler.on("test", function (data) {
      if (testMessageProcessed) {
        return;
      }
      testMessageProcessed = true;
      if (!(data instanceof Uint8Array)) {
        handler.send("test", "main", false);
        return;
      }
      const supportTransfers = data.length === 0;
      handler.send("test", "main", supportTransfers);
    });
    handler.on("configure", function (data) {
      (0, _util2.setVerbosityLevel)(data.verbosity);
    });
    handler.on("create", function (data) {
      this.context = {
        data,
        beginCombineFun: null,
        endCombineFun: null
      };
      handler.send("created", data, null);
    });
  },
  create(context, name) {
    const task = new WorkerTask(name);
    task.transport = context;
    return task;
  },
  async run(task, action, data) {
    try {
      const result = await this.actions[action].call(this, task, data);
      task.resolve(result);
    } catch (reason) {
      task.reject(reason);
    }
  },
  actions: {
    async Grayscale(task, data) {
      const src = data.src;
      const {
        width,
        height
      } = data;
      const dest = new Uint8ClampedArray(src.length);
      let i = 0,
        j = 0;
      const numPixels = width * height;
      for (i = 0; i < numPixels; i++) {
        const r = src[j++],
          g = src[j++],
          b = src[j++];
        dest[i] = r * 0.299 + g * 0.587 + b * 0.114;
      }
      return dest;
    },
    async Negate(task, data) {
      const src = data.src;
      const dest = new Uint8ClampedArray(src.length);
      for (let i = 0, ii = src.length; i < ii; i++) {
        dest[i] = 255 - src[i];
      }
      return dest;
    },
    async Sepia(task, data) {
      const src = data.src;
      const dest = new Uint8ClampedArray(src.length);
      let i = 0,
        j = 0;
      const numPixels = data.width * data.height;
      for (i = 0; i < numPixels; i++) {
        const r = src[j],
          g = src[j + 1],
          b = src[j + 2];
        dest[j++] = r * 0.393 + g * 0.769 + b * 0.189;
        dest[j++] = r * 0.349 + g * 0.686 + b * 0.168;
        dest[j++] = r * 0.272 + g * 0.534 + b * 0.131;
      }
      return dest;
    },
    async JpxDecode(task, data) {
      const jpxImage = new _jpx.JpxImage();
      jpxImage.parse(data);
      const width = jpxImage.width;
      const height = jpxImage.height;
      const componentsCount = jpxImage.componentsCount;
      const {
        imageData,
        isAlpha
      } = jpxImage;
      if (isAlpha && componentsCount !== 4) {
        throw new _util.NotSupportedException("JPX images with 2, 5, etc. components aren't supported.");
      }
      return {
        width,
        height,
        data: imageData,
        alpha: isAlpha ? imageData.subarray(3, 4 * width * height) : null,
        componentsCount
      };
    }
  }
};
exports.WorkerMessageHandler = WorkerMessageHandler;

/***/ }),
/* 9 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.PDFImage = void 0;
var _util = __webpack_require__(1);
var _util2 = __webpack_require__(2);
var _primitives = __webpack_require__(4);
class PDFImage {
  static async buildImage(options) {
    const {
      xref,
      res,
      image,
      isInline = false,
      operatorList,
      colorspace = null,
      cacheKey = ""
    } = options;
    const {
      dict,
      isAsync,
      canAsyncDecode
    } = image;
    const imageDict = image.dict;
    const width = imageDict.get("W", "Width");
    const height = imageDict.get("H", "Height");
    if (!(Number.isInteger(width) && width > 0 && Number.isInteger(height) && height > 0)) {
      throw new _util.FormatError(`Invalid image dimensions: ${width}x${height}`);
    }
    const bitsPerComponent = imageDict.get("BPC", "BitsPerComponent") || 1;
    if (![1, 2, 4, 8, 12, 16].includes(bitsPerComponent)) {
      throw new _util.FormatError(`Unsupported "BitsPerComponent": ${bitsPerComponent}`);
    }
    let imgData;
    if (!isInline) {
      if (image.isResolved) {
        if (!image.isEmpty) {
          imgData = image.getBytes();
        }
      } else {
        if (!isAsync) {
          image.decode();
        } else {
          await image.decodeAsync();
        }
        if (!image.isEmpty) {
          imgData = image.stream.getBytes();
        }
      }
    }
    const kind = this.getImageKind(imageDict);
    const objId = (0, _primitives.isRef)(image.dict) ? image.dict.toString() : `inline_${isInline}_${cacheKey}`;
    const w = new Worker("pdf.worker.js", {
      type: "module"
    });
    const task = new WorkerTask(`image_${objId}_${width}x${height}`);
    const workerHandler = WorkerMessageHandler.create(w, task);
    let result = null;
    let transfers = null;
    if (kind === "jpg") {
      const data = {
        src: imgData,
        width,
        height
      };
      if (bitsPerComponent === 1) {
        data.action = "invert";
      }
      result = await workerHandler.request("JpegDecode", data);
    } else {
      const SMask = imageDict.get("SMask");
      const mask = imageDict.get("Mask");
      if (SMask) {
        const smaskData = await this.buildImage({
          xref,
          res,
          image: new Stream(SMask.stream.str, 0, SMask.stream.length, SMask.dict),
          isInline: false,
          operatorList,
          colorspace: null,
          cacheKey: cacheKey + "_smask"
        });
        const smaskInData = {
          src: smaskData.data,
          width,
          height,
          componentsCount: smaskData.componentsCount,
          bpc: bitsPerComponent
        };
        const smaskOutData = await workerHandler.request("GrayScale", smaskInData);
        const smaskDataOut = smaskOutData;
        const alpha = new Uint8Array(width * height);
        let i = 0;
        const ii = smaskDataOut.length;
        while (i < ii) {
          alpha[i] = smaskDataOut[i];
          i++;
        }
      } else if (mask) {
        if (Array.isArray(mask)) {
          const numColor = colorspace.numComps;
          const maskArray = [];
          for (let i = 0, ii = 2 * numColor; i < ii; i++) {
            const v = mask[i];
            maskArray.push(v / (bitsPerComponent === 8 ? 255 : 1));
          }
        } else if ((0, _primitives.isStream)(mask)) {
          const maskDict = mask.dict;
          const maskWidth = maskDict.get("W", "Width");
          const maskHeight = maskDict.get("H", "Height");
          const maskData = await this.buildImage({
            xref,
            res,
            image: new Stream(mask.str, 0, mask.length, maskDict),
            isInline: false,
            operatorList,
            colorspace: null,
            cacheKey: cacheKey + "_mask"
          });
        }
      }
    }
  }
  static getImageKind(imageDict) {
    const filter = imageDict.get("F", "Filter");
    const filterName = (0, _primitives.isName)(filter) ? filter.name : Array.isArray(filter) && (0, _primitives.isName)(filter[0]) ? filter[0].name : "";
    switch (filterName) {
      case "DCT":
      case "DCTDecode":
        return "jpg";
      case "JPX":
      case "JPXDecode":
        return "jpx";
      case "A85":
      case "ASCII85Decode":
        return "a85";
      case "CCF":
      case "CCITTFaxDecode":
        return "ccf";
      default:
        return "load";
    }
  }
}
exports.PDFImage = PDFImage;
var WorkerTask = __webpack_require__(8).WorkerTask;
var WorkerMessageHandler = __webpack_require__(8).WorkerMessageHandler;
var Stream = __webpack_require__(4).Stream;

/***/ }),
/* 10 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.MessageHandler = void 0;
var _util = __webpack_require__(1);
var _util2 = __webpack_require__(2);
var _primitives = __webpack_require__(4);
var _parser = __webpack_require__(3);
var _core_utils = __webpack_require__(5);
var _image_utils = __webpack_require__(9);
var _worker = __webpack_require__(8);
class MessageHandler {
  constructor(name, comObj, worker) {
    this.name = name;
    this.comObj = comObj;
    this.worker = worker;
    this.callbackId = 1;
    this.callbacks = new Map();
    this.actionHandler = Object.create(null);
    this.comObj.onmessage = this.onMessage.bind(this);
  }
  on(actionName, handler) {
    this.actionHandler[actionName] = handler;
  }
  send(actionName, data, transfers) {
    const message = {
      action: actionName,
      data
    };
    if (this.worker) {
      this.comObj.postMessage(message, transfers);
    } else {
      this.comObj.postMessage(message);
    }
  }
  sendWithPromise(actionName, data, transfers) {
    const callbackId = this.callbackId++;
    const capability = (0, _util2.createPromiseCapability)();
    this.callbacks.set(callbackId, capability);
    const message = {
      action: actionName,
      callbackId,
      data
    };
    if (this.worker) {
      this.comObj.postMessage(message, transfers);
    } else {
      this.comObj.postMessage(message);
    }
    return capability.promise;
  }
  onMessage(event) {
    const message = event.data;
    if (message.pdfjsWorker) {
      this.worker.messageHandler.onMessage(event);
      return;
    }
    const {
      action,
      data,
      callbackId,
      sourceName
    } = message;
    if (sourceName && sourceName !== this.name) {
      return;
    }
    if (action) {
      const handler = this.actionHandler[action];
      if (handler) {
        try {
          handler.call(this, data);
        } catch (ex) {
          (0, _util2.warn)(`Uncaught exception in message handler for action "${action}"` + `: ${ex?.message}`);
        }
      } else {
        throw new _util.NotImplementedException(`Unknown action from worker: ${action}`);
      }
    } else if (callbackId) {
      const capability = this.callbacks.get(callbackId);
      if (capability) {
        this.callbacks.delete(callbackId);
        if ("error" in data) {
          capability.reject(data.error);
        } else {
          capability.resolve(data);
        }
      } else {
        throw new _util.NotImplementedException(`Cannot resolve callback ${callbackId}`);
      }
    } else {
      throw new _util.NotImplementedException("Unexpected message from worker");
    }
  }
}
exports.MessageHandler = MessageHandler;

/***/ }),
/* 11 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.WorkerTransport = void 0;
var _util = __webpack_require__(1);
var _util2 = __webpack_require__(2);
var _primitives = __webpack_require__(4);
var _parser = __webpack_require__(3);
var _core_utils = __webpack_require__(5);
var _message_handler = __webpack_require__(10);
var _worker_stream = __webpack_require__(12);
var _image_utils = __webpack_require__(9);
var _worker2 = __webpack_require__(8);
class WorkerTransport {
  constructor(messageHandler, port, worker) {
    this.messageHandler = messageHandler;
    this.port = port;
    this.worker = worker;
    this.enabled = true;
    this.outstanding = new Map();
    this.stream = null;
    this.passwordCallback = null;
    this.docId = null;
    this.fontCallback = null;
    this.messageHandler.on("doc", this._onDoc.bind(this));
    this.messageHandler.on("page_create", this._onPageCreate.bind(this));
    this.messageHandler.on("page_paint", this._onPagePaint.bind(this));
    this.messageHandler.on("page_get_text", this._onPageGetText.bind(this));
    this.messageHandler.on("page_get_annotations", this._onPageGetAnnotations.bind(this));
    this.messageHandler.on("font_ready", this._onFontReady.bind(this));
    this.messageHandler.on("password", this._onPassword.bind(this));
    this.messageHandler.on("error", this._onError.bind(this));
    this.messageHandler.on("terminate", this._onTerminate.bind(this));
  }
  _onDoc(data) {
    const {
      docId,
      docInfo
    } = data;
    this.docId = docId;
    this.stream = new _worker_stream.WorkerStream(this.messageHandler, docId, docInfo.length);
    const doc = new Document(this, this.stream, docInfo);
    this.outstanding.set(docId, doc);
  }
  _onPageCreate(data) {
    const {
      docId,
      pageId,
      pageInfo
    } = data;
    const doc = this.outstanding.get(docId);
    if (!doc) {
      throw new Error(`No document found for ${docId}`);
    }
    const page = new Page(this, docId, pageId, pageInfo);
    doc.pages.push(page);
  }
  _onPagePaint(data) {
    const {
      docId,
      pageId
    } = data;
    const doc = this.outstanding.get(docId);
    if (!doc) {
      throw new Error(`No document found for ${docId}`);
    }
    const page = doc.pages[pageId - 1];
    if (!page) {
      throw new Error(`No page found for ${pageId}`);
    }
    page.paint(data.bitmap, data.width, data.height);
  }
  _onPageGetText(data) {
    const {
      docId,
      pageId
    } = data;
    const doc = this.outstanding.get(docId);
    if (!doc) {
      throw new Error(`No document found for ${docId}`);
    }
    const page = doc.pages[pageId - 1];
    if (!page) {
      throw new Error(`No page found for ${pageId}`);
    }
    const capability = page.getTextCapability;
    page.getTextCapability = null;
    capability.resolve(data.textContent);
  }
  _onPageGetAnnotations(data) {
    const {
      docId,
      pageId
    } = data;
    const doc = this.outstanding.get(docId);
    if (!doc) {
      throw new Error(`No document found for ${docId}`);
    }
    const page = doc.pages[pageId - 1];
    if (!page) {
      throw new Error(`No page found for ${pageId}`);
    }
    const capability = page.getAnnotationsCapability;
    page.getAnnotationsCapability = null;
    capability.resolve(data.annotations);
  }
  _onFontReady(data) {
    const {
      docId,
      fontId
    } = data;
    const doc = this.outstanding.get(docId);
    if (!doc) {
      throw new Error(`No document found for ${docId}`);
    }
    const font = doc.fonts.get(fontId);
    if (!font) {
      throw new Error(`No font found for ${fontId}`);
    }
    font.ready();
  }
  _onPassword(data) {
    const {
      docId,
      reason,
      password
    } = data;
    const doc = this.outstanding.get(docId);
    if (!doc) {
      throw new Error(`No document found for ${docId}`);
    }
    const callback = this.passwordCallback;
    this.passwordCallback = null;
    callback(password, reason);
  }
  _onError(data) {
    const {
      docId,
      message,
      name
    } = data;
    const doc = this.outstanding.get(docId);
    if (!doc) {
      throw new Error(`No document found for ${docId}`);
    }
    doc.error(message, name);
  }
  _onTerminate(data) {
    this.enabled = false;
  }
  loadDocument(url, options) {
    const docId = `doc_${this.outstanding.size}`;
    this.messageHandler.send("load", {
      docId,
      url,
      options
    });
    return this.outstanding.get(docId);
  }
}
exports.WorkerTransport = WorkerTransport;
class Document {
  constructor(transport, stream, docInfo) {
    this.transport = transport;
    this.stream = stream;
    this.docInfo = docInfo;
    this.pages = [];
    this.fonts = new Map();
    this.error = null;
    this.passwordCallback = null;
  }
  get numPages() {
    return this.docInfo.numPages;
  }
  getPage(pageNumber) {
    return this.pages[pageNumber - 1];
  }
  error(message, name) {
    this.error = {
      message,
      name
    };
    if (this.passwordCallback) {
      this.passwordCallback(null, this.error);
    }
  }
}
class Page {
  constructor(transport, docId, pageId, pageInfo) {
    this.transport = transport;
    this.docId = docId;
    this.pageId = pageId;
    this.pageInfo = pageInfo;
    this.getTextCapability = null;
    this.getAnnotationsCapability = null;
  }
  paint(bitmap, width, height) {
    const canvas = document.createElement("canvas");
    canvas.width = width;
    canvas.height = height;
    const ctx = canvas.getContext("2d");
    const imageData = ctx.createImageData(width, height);
    imageData.data.set(bitmap);
    ctx.putImageData(imageData, 0, 0);
    document.body.appendChild(canvas);
  }
  getTextContent() {
    this.getTextCapability = (0, _util2.createPromiseCapability)();
    this.transport.messageHandler.send("page_get_text", {
      docId: this.docId,
      pageId: this.pageId
    });
    return this.getTextCapability.promise;
  }
  getAnnotations() {
    this.getAnnotationsCapability = (0, _util2.createPromiseCapability)();
    this.transport.messageHandler.send("page_get_annotations", {
      docId: this.docId,
      pageId: this.pageId
    });
    return this.getAnnotationsCapability.promise;
  }
}

/***/ }),
/* 12 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.WorkerStream = void 0;
var _stream = __webpack_require__(6);
var _util = __webpack_require__(1);
var _util2 = __webpack_require__(2);
class WorkerStream extends _stream.BaseStream {
  constructor(msgHandler, docId, length) {
    super();
    this.msgHandler = msgHandler;
    this.docId = docId;
    this._length = length;
    this._disableRange = false;
    this._isStreamingSupported = false;
    this._isRangeSupported = false;
    this.msgHandler.on("chunk", this._onChunk.bind(this));
    this._loadedChunks = [];
    this.requests = [];
    this.progressiveDataLength = 0;
    this._chunkSize = 0;
    this.aborted = false;
    this.canRequestLess = true;
    this.cache = Object.create(null);
  }
  get isDataLoaded() {
    return this._isStreamingSupported && this.progressiveDataLength >= this.length;
  }
  get isStreamingSupported() {
    return this._isStreamingSupported;
  }
  set isStreamingSupported(val) {
    this._isStreamingSupported = val;
  }
  get isRangeSupported() {
    return this._isRangeSupported;
  }
  set isRangeSupported(val) {
    this._isRangeSupported = val;
  }
  get length() {
    return this._length;
  }
  _onChunk(data) {
    const {
      chunk,
      begin,
      end
    } = data;
    this._loadedChunks.push({
      begin,
      end,
      chunk
    });
    const request = this.requests.shift();
    request.resolve();
  }
  getByte() {
    const pos = this.pos;
    if (pos >= this.length) {
      return -1;
    }
    const chunk = this._getChunk(pos, 1);
    if (!chunk) {
      return -1;
    }
    return chunk[pos - this._getChunkOffset(pos)];
  }
  getBytes(length) {
    const pos = this.pos;
    if (pos >= this.length) {
      return null;
    }
    const n = Math.min(length, this.length - pos);
    const chunk = this._getChunk(pos, n);
    if (!chunk) {
      return null;
    }
    const chunkOffset = this._getChunkOffset(pos);
    const bytes = chunk.subarray(pos - chunkOffset, pos - chunkOffset + n);
    this.pos += n;
    return bytes;
  }
  _getChunk(pos, length) {
    for (const chunk of this._loadedChunks) {
      if (pos >= chunk.begin && pos + length <= chunk.end) {
        return chunk.chunk;
      }
    }
    if (this.canRequestLess) {
      this._request(pos, length);
    }
    return null;
  }
  _getChunkOffset(pos) {
    for (const chunk of this._loadedChunks) {
      if (pos >= chunk.begin && pos < chunk.end) {
        return chunk.begin;
      }
    }
    return 0;
  }
  _request(begin, length) {
    const capability = (0, _util2.createPromiseCapability)();
    this.requests.push(capability);
    this.msgHandler.send("requestData", {
      docId: this.docId,
      begin,
      length
    });
  }
}
exports.WorkerStream = WorkerStream;

/***/ }),
/* 13 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.workerSrc = exports.isNodeJS = void 0;
var _util = __webpack_require__(2);
const isNodeJS = function () {
  return typeof process === "object" && process.versions && process.versions.node;
}();
exports.isNodeJS = isNodeJS;
let workerSrc = "";
exports.workerSrc = workerSrc;
if (isNodeJS) {
  (0, _util.setVerbosityLevel)(_util.VerbosityLevel.ERRORS);
} else if (typeof PDFJSDev === "undefined" || !PDFJSDev.test("MOZCENTRAL")) {
  if (typeof document !== "undefined") {
    exports.workerSrc = workerSrc = (document.currentScript?.src || "").split("?")[0];
  } else if (typeof self !== "undefined") {
    exports.workerSrc = workerSrc = self.location.href.split("?")[0];
  }
}

/***/ }),
/* 14 */
/***/ ((__unused_webpack_module, exports) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.PrivatePromise = exports.PromiseOut = void 0;
class PromiseOut {
  constructor() {
    this.isFinished = false;
    this.promise = new Promise((resolve, reject) => {
      this.resolve = value => {
        if (!this.isFinished) {
          this.isFinished = true;
          resolve(value);
        }
      };
      this.reject = reason => {
        if (!this.isFinished) {
          this.isFinished = true;
          reject(reason);
        }
      };
    });
  }
}
exports.PromiseOut = PromiseOut;
class PrivatePromise {
  constructor(reason) {
    this.reason = reason;
  }
  then(resolve, reject) {
    return Promise.reject(this.reason).then(resolve, reject);
  }
}
exports.PrivatePromise = PrivatePromise;

/***/ }),
/* 15 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.CMapFactory = exports.CMap = void 0;
var _util = __webpack_require__(2);
var _util2 = __webpack_require__(1);
var _stream = __webpack_require__(6);
var _primitives = __webpack_require__(4);
class CMap {
  constructor(builtInCMap = false) {
    this.name = "";
    this.version = "";
    this.useCMap = null;
    this.wmode = 0;
    this.vertical = false;
    this.builtInCMap = builtInCMap;
    this._map = [];
    this._readOnly = false;
  }
  addCodes(low, high, code) {
    if (this._readOnly) {
      throw new Error("Writing to a CMap after it has been used is not supported.");
    }
    this._map.push({
      low,
      high,
      code
    });
  }
  mapCidRange(low, high, dstLow) {
    this.addCodes(low, high, dstLow);
  }
  mapOne(one, two) {
    this.addCodes(one, one, two);
  }
  getCharCode(code) {
    let charCode = code;
    for (const {
      low,
      high,
      code
    } of this._map) {
      if (typeof code === "number") {
        if (charCode >= low && charCode <= high) {
          charCode = charCode - low + code;
          break;
        }
      } else {
        const i = (0, _util.binarySearchFirstItem)(code, c => c >= charCode);
        if (i < code.length && code[i] === charCode) {
          charCode = String.fromCharCode(low + i);
          break;
        }
      }
    }
    return charCode;
  }
  forEach(callback) {
    this._readOnly = true;
    for (const {
      low,
      high,
      code
    } of this._map) {
      if (typeof code === "number") {
        for (let i = low; i <= high; i++) {
          callback(i, i - low + code);
        }
      } else {
        for (let i = 0, ii = code.length; i < ii; i++) {
          callback(code[i], low + i);
        }
      }
    }
  }
  get length() {
    this._readOnly = true;
    let count = 0;
    for (const {
      low,
      high,
      code
    } of this._map) {
      if (typeof code === "number") {
        count += high - low + 1;
      } else {
        count += code.length;
      }
    }
    return count;
  }
  getMap() {
    this._readOnly = true;
    const map = new Map();
    this.forEach((key, value) => {
      map.set(key, value);
    });
    return map;
  }
  export() {
    this._readOnly = true;
    const map = new Map();
    for (const {
      low,
      high,
      code
    } of this._map) {
      if (typeof code === "number") {
        for (let i = low; i <= high; i++) {
          map.set(i, i - low + code);
        }
      } else {
        for (let i = 0, ii = code.length; i < ii; i++) {
          map.set(code[i], low + i);
        }
      }
    }
    return map;
  }
  get isIdentityCMap() {
    if (this.builtInCMap) {
      return this.name === "Identity-H" || this.name === "Identity-V";
    }
    if (this.length !== 1) {
      return false;
    }
    const {
      low,
      high,
      code
    } = this._map[0];
    return low === 0 && high === 0xFFFF && code === 0;
  }
}
exports.CMap = CMap;
const CMapFactory = function CMapFactoryClosure() {
  function strToInt(str) {
    let a = 0;
    for (let i = 0; i < str.length; i++) {
      a = a << 8 | str.charCodeAt(i);
    }
    return a;
  }
  function hexToInt(str) {
    let a = 0;
    for (let i = 0; i < str.length; i++) {
      const digit = str[i];
      let b;
      if ("0" <= digit && digit <= "9") {
        b = digit - "0";
      } else if ("a" <= digit && digit <= "f") {
        b = digit.charCodeAt(0) - "a".charCodeAt(0) + 10;
      } else if ("A" <= digit && digit <= "F") {
        b = digit.charCodeAt(0) - "A".charCodeAt(0) + 10;
      } else {
        return NaN;
      }
      a = (a << 4) + b;
    }
    return a;
  }
  function parseCMap(stream, options) {
    function readInt(str) {
      const task = new CMapTask();
      const REX = /^\s*(\d+)\s*(\S*)/;
      const m = REX.exec(str);
      task.num = parseInt(m[1]);
      task.cmd = m[2];
      return task;
    }
    function readHex(str) {
      const task = new CMapTask();
      const REX = /^\s*<([0-9A-Fa-f]*)>\s*(\S*)/;
      const m = REX.exec(str);
      task.buf = m[1];
      task.cmd = m[2];
      return task;
    }
    function readStr(str) {
      const task = new CMapTask();
      const REX = /^\s*\((\d+)\)\s*(\S*)/;
      const m = REX.exec(str);
      task.buf = m[1];
      task.cmd = m[2];
      return task;
    }
    const CMapTask = function CMapTaskClosure() {
      function CMapTask() {}
      return CMapTask;
    }();
    const c = new CMap(options.builtInCMap);
    const stack = [];
    let task;
    const MAX_LINE_LENGTH = 4096;
    const lineReader = new _stream.StreamReader(stream);
    while (!lineReader.eof) {
      const line = lineReader.peekBytes(MAX_LINE_LENGTH);
      const lineStr = (0, _util.bytesToString)(line);
      const m = /([^\r\n]*)(?:\r\n?|\n)/.exec(lineStr);
      if (m) {
        lineReader.skip(m[0].length);
      } else {
        lineReader.skip(line.length);
      }
      const lineTrim = m ? m[1].trim() : lineStr.trim();
      const lineParts = lineTrim.split(/\s+/);
      for (const part of lineParts) {
        switch (part[0]) {
          case "(":
            task = readStr(part);
            stack.push(task.buf);
            break;
          case "<":
            task = readHex(part);
            stack.push(task.buf);
            break;
          case "/":
            stack.push(part.substring(1));
            break;
          case "[":
            stack.push(part);
            break;
          case "]":
            stack.push(part);
            break;
          default:
            if (!isNaN(part)) {
              stack.push(parseInt(part));
            } else {
              stack.push(part);
            }
            break;
        }
      }
      const lastCmd = stack.at(-1);
      switch (lastCmd) {
        case "begincidrange":
          {
            const count = stack.at(-2);
            for (let i = 0; i < count; i++) {
              c.mapCidRange(hexToInt(stack.at(-4 - i * 3)), hexToInt(stack.at(-3 - i * 3)), hexToInt(stack.at(-2 - i * 3)));
            }
            stack.length = 0;
            break;
          }
        case "beginbfchar":
          {
            const count = stack.at(-2);
            for (let i = 0; i < count; i++) {
              c.mapOne(hexToInt(stack.at(-3 - i * 2)), hexToInt(stack.at(-2 - i * 2)));
            }
            stack.length = 0;
            break;
          }
        case "def":
        case "gdef":
          stack.length = 0;
          break;
      }
    }
    return c;
  }
  return {
    async create(options) {
      const {
        encoding,
        font,
        url,
        builtInCMap = false
      } = options;
      let name;
      if ((0, _primitives.isName)(encoding)) {
        name = encoding.name;
      } else if ((0, _util.isString)(encoding)) {
        name = encoding;
      } else {
        throw new Error("Encoding required.");
      }
      const c = new CMap(builtInCMap);
      if (name === "Identity-H") {
        c.name = name;
        c.vertical = false;
        c.wmode = 0;
        return c;
      }
      if (name === "Identity-V") {
        c.name = name;
        c.vertical = true;
        c.wmode = 1;
        return c;
      }
      let stream;
      if (font.cMap) {
        stream = font.cMap.stream;
      } else if (url) {
        try {
          const response = await fetch(url);
          if (response.ok) {
            const buffer = await response.arrayBuffer();
            stream = new _stream.BaseStream();
            stream.buffer = buffer;
          } else {
            throw new _util2.UnknownErrorException(`CMap url, "${url}", is not found.`);
          }
        } catch (ex) {
          throw new _util2.UnknownErrorException(`CMap url, "${url}", is not found.`);
        }
      } else {
        throw new Error("CMap is not defined.");
      }
      return parseCMap(stream, options);
    }
  };
}();
exports.CMapFactory = CMapFactory;

/***/ })
/******/ 	]);
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
var __webpack_exports__ = {};
// This entry need to be wrapped in an IIFE because it need to be isolated against other modules in the chunk.
(() => {
var exports = __webpack_exports__;


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.PDFWorker = void 0;
var _util = __webpack_require__(1);
var _util2 = __webpack_require__(2);
var _message_handler = __webpack_require__(10);
var _primitives = __webpack_require__(4);
var _core_utils = __webpack_require__(5);
var _parser = __webpack_require__(3);
var _image_utils = __webpack_require__(9);
var _worker = __webpack_require__(8);
var _platform = __webpack_require__(13);
var _private_utils = require("./private_utils.js");
var _promise_utils = __webpack_require__(14);
var _cmap = __webpack_require__(15);
class WorkerMessageHandler {
  static setup(handler, port) {
    let testMessageProcessed = false;
    handler.on("test", function (data) {
      if (testMessageProcessed) {
        return;
      }
      testMessageProcessed = true;
      if (!(data instanceof Uint8Array)) {
        handler.send("test", null, false);
        return;
      }
      const supportTransfers = data.length === 0;
      handler.send("test", null, supportTransfers);
    });
    handler.on("configure", function (data) {
      (0, _util2.setVerbosityLevel)(data.verbosity);
    });
    handler.on("load", async function (data) {
      const {
        docId,
        url,
        options
      } = data;
      try {
        const {
          isOffscreenCanvasSupported,
          fontExtraProperties
        } = options;
        const worker = new PDFWorker(docId, url, isOffscreenCanvasSupported, fontExtraProperties, port);
        const docInfo = await worker.loadDocument();
        this.send("doc", {
          docId,
          docInfo
        });
      } catch (ex) {
        if (ex.name === "PasswordException") {
          this.send("password", {
            docId,
            reason: ex
          });
        } else {
          this.send("error", {
            docId,
            message: ex.message,
            name: ex.name
          });
        }
      }
    });
    handler.on("page_create", async function (data) {
      const {
        docId,
        pageId,
        pageIndex
      } = data;
      const worker = PDFWorker.workers[docId];
      if (!worker) {
        throw new Error(`No worker found for ${docId}`);
      }
      const pageInfo = await worker.getPageInfo(pageIndex);
      this.send("page_create", {
        docId,
        pageId,
        pageInfo
      });
    });
    handler.on("page_paint", async function (data) {
      const {
        docId,
        pageId,
        bitmap,
        width,
        height
      } = data;
      const worker = PDFWorker.workers[docId];
      if (!worker) {
        throw new Error(`No worker found for ${docId}`);
      }
      const page = worker.pages[pageId - 1];
      if (!page) {
        throw new Error(`No page found for ${pageId}`);
      }
      page.paint(bitmap, width, height);
    });
    handler.on("page_get_text", async function (data) {
      const {
        docId,
        pageId
      } = data;
      const worker = PDFWorker.workers[docId];
      if (!worker) {
        throw new Error(`No worker found for ${docId}`);
      }
      const page = worker.pages[pageId - 1];
      if (!page) {
        throw new Error(`No page found for ${pageId}`);
      }
      const textContent = await page.getTextContent();
      this.send("page_get_text", {
        docId,
        pageId,
        textContent
      });
    });
    handler.on("page_get_annotations", async function (data) {
      const {
        docId,
        pageId
      } = data;
      const worker = PDFWorker.workers[docId];
      if (!worker) {
        throw new Error(`No worker found for ${docId}`);
      }
      const page = worker.pages[pageId - 1];
      if (!page) {
        throw new Error(`No page found for ${pageId}`);
      }
      const annotations = await page.getAnnotations();
      this.send("page_get_annotations", {
        docId,
        pageId,
        annotations
      });
    });
    handler.on("font_ready", function (data) {
      const {
        docId,
        fontId
      } = data;
      const worker = PDFWorker.workers[docId];
      if (!worker) {
        throw new Error(`No worker found for ${docId}`);
      }
      const font = worker.fonts.get(fontId);
      if (!font) {
        throw new Error(`No font found for ${fontId}`);
      }
      font.ready();
    });
  }
}
class PDFWorker {
  constructor(docId, url, isOffscreenCanvasSupported, fontExtraProperties, port) {
    this.docId = docId;
    this.url = url;
    this.isOffscreenCanvasSupported = isOffscreenCanvasSupported;
    this.fontExtraProperties = fontExtraProperties;
    this.port = port;
    this.pdfManager = null;
    this.pages = [];
    this.fonts = new Map();
    PDFWorker.workers[docId] = this;
  }
  static get workers() {
    return Object.defineProperty(this, "workers", {
      value: Object.create(null)
    }).workers;
  }
  async loadDocument() {
    const {
      PDFDataRangeTransport
    } = __webpack_require__(11);
    const {
      PDFDocumentLoadingTask
    } = __webpack_require__(12);
    const loadingTask = new PDFDocumentLoadingTask();
    const transport = new PDFDataRangeTransport({
      length: 0,
      initialData: null
    }, {
      owner: loadingTask,
      isStreamingSupported: true,
      isRangeSupported: true
    });
    loadingTask.onPassword = (updatePassword, reason) => {
      this.port.postMessage({
        action: "password",
        reason
      });
      this.port.onmessage = event => {
        updatePassword(event.data.password);
      };
    };
    loadingTask.onProgress = progressData => {
      this.port.postMessage({
        action: "progress",
        data: progressData
      });
    };
    this.pdfManager = await loadingTask.promise;
    return this.pdfManager.docInfo;
  }
  async getPageInfo(pageIndex) {
    const page = await this.pdfManager.getPage(pageIndex + 1);
    this.pages.push(page);
    return page.pageInfo;
  }
}
exports.PDFWorker = PDFWorker;
if (typeof self !== "undefined") {
  WorkerMessageHandler.setup(new _message_handler.MessageHandler("worker", self), self);
}
})();

/******/ })()
;
//# sourceMappingURL=pdf.worker.js.map
